//! VM-Core Coverage Boost Tests
//!
//! This test file targets to increase vm-core coverage to 85%+

use std::collections::HashMap;
use std::sync::{Arc, Mutex};

use vm_core::{
    GuestAddr, GuestVAddr, HostPtr, VmError, VmResult,
    event_sourcing::{Event, EventId, EventMetadata, EventStore, InMemoryEventStore},
};

// ============================================================================
// Event Sourcing Tests (High Impact - 16/92 lines)
// ============================================================================

#[test]
fn test_event_id_generation() {
    let id1 = EventId::new();
    let id2 = EventId::new();
    assert_ne!(id1, id2);
}

#[test]
fn test_event_id_from_bytes() {
    let bytes = [1u8; 16];
    let id = EventId::from_bytes(bytes);
    assert_eq!(id.as_bytes(), bytes);
}

#[test]
fn test_event_metadata_creation() {
    let metadata = EventMetadata::new();
    assert_eq!(metadata.version(), 1);
}

#[test]
fn test_event_metadata_with_correlation_id() {
    let metadata = EventMetadata::new().with_correlation_id("test-correlation".to_string());
    assert_eq!(metadata.correlation_id(), Some("test-correlation"));
}

#[test]
fn test_event_metadata_with_causation_id() {
    let metadata = EventMetadata::new().with_causation_id("test-causation".to_string());
    assert_eq!(metadata.causation_id(), Some("test-causation"));
}

#[test]
fn test_in_memory_event_store_append() {
    let store = InMemoryEventStore::new();
    let event = TestEvent::new("test-event".to_string());

    let result = store.append_event(event.clone());
    assert!(result.is_ok());
}

#[test]
fn test_in_memory_event_store_retrieve() {
    let store = InMemoryEventStore::new();
    let event = TestEvent::new("test-event".to_string());
    let event_id = event.id();

    store.append_event(event).unwrap();

    let retrieved = store.get_event(event_id);
    assert!(retrieved.is_ok());
}

#[test]
fn test_in_memory_event_store_retrieve_all() {
    let store = InMemoryEventStore::new();
    let event1 = TestEvent::new("event-1".to_string());
    let event2 = TestEvent::new("event-2".to_string());

    store.append_event(event1).unwrap();
    store.append_event(event2).unwrap();

    let all_events = store.get_all_events();
    assert!(all_events.is_ok());
    assert_eq!(all_events.unwrap().len(), 2);
}

#[test]
fn test_event_serialization() {
    let event = TestEvent::new("test-event".to_string());
    let serialized = serde_json::to_string(&event);
    assert!(serialized.is_ok());
}

#[test]
fn test_event_deserialization() {
    let event = TestEvent::new("test-event".to_string());
    let serialized = serde_json::to_string(&event).unwrap();
    let deserialized: TestEvent = serde_json::from_str(&serialized).unwrap();
    assert_eq!(event.id(), deserialized.id());
}

// Test Event Implementation
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
struct TestEvent {
    id: EventId,
    metadata: EventMetadata,
    event_type: String,
    data: String,
}

impl TestEvent {
    fn new(data: String) -> Self {
        Self {
            id: EventId::new(),
            metadata: EventMetadata::new(),
            event_type: "TestEvent".to_string(),
            data,
        }
    }

    fn id(&self) -> EventId {
        self.id
    }
}

impl Event for TestEvent {
    fn event_type(&self) -> &str {
        &self.event_type
    }

    fn metadata(&self) -> &EventMetadata {
        &self.metadata
    }
}

// ============================================================================
// Template Tests (High Impact - 0/11 lines)
// ============================================================================

#[test]
fn test_vm_config_default() {
    use vm_core::Config;
    let config = Config::default();
    assert_eq!(config.num_vcpus(), 1);
}

#[test]
fn test_vm_config_builder() {
    use vm_core::Config;
    let config = Config::builder()
        .with_vcpus(4)
        .with_memory(1024 * 1024 * 1024)
        .build();

    assert_eq!(config.num_vcpus(), 4);
}

#[test]
fn test_vm_config_clone() {
    use vm_core::Config;
    let config = Config::default();
    let cloned = config.clone();
    assert_eq!(config.num_vcpus(), cloned.num_vcpus());
}

// ============================================================================
// VM State Tests (High Impact - 0/22 lines)
// ============================================================================

#[test]
fn test_vm_state_creation() {
    use vm_core::VmState;
    let state = VmState::new();
    assert!(!state.is_running());
}

#[test]
fn test_vm_state_start() {
    use vm_core::VmState;
    let mut state = VmState::new();
    state.start();
    assert!(state.is_running());
}

#[test]
fn test_vm_state_stop() {
    use vm_core::VmState;
    let mut state = VmState::new();
    state.start();
    state.stop();
    assert!(!state.is_running());
}

#[test]
fn test_vm_state_pause_resume() {
    use vm_core::VmState;
    let mut state = VmState::new();
    state.start();
    state.pause();
    assert!(state.is_paused());
    state.resume();
    assert!(!state.is_paused());
}

#[test]
fn test_vm_state_reset() {
    use vm_core::VmState;
    let mut state = VmState::new();
    state.start();
    state.reset();
    assert!(!state.is_running());
}

// ============================================================================
// Syscall Tests (High Impact - 16/92 lines)
// ============================================================================

#[test]
fn test_syscall_table_registration() {
    use vm_core::syscall::SyscallTable;
    let table = SyscallTable::new();
    assert!(table.is_empty());
}

#[test]
fn test_syscall_registration() {
    use vm_core::syscall::{Syscall, SyscallHandler, SyscallTable};

    struct TestHandler;
    impl SyscallHandler for TestHandler {
        fn handle(&self, _args: &[u64]) -> VmResult<u64> {
            Ok(42)
        }
    }

    let mut table = SyscallTable::new();
    table.register(1, Box::new(TestHandler));
    assert!(!table.is_empty());
}

#[test]
fn test_syscall_execution() {
    use vm_core::syscall::{Syscall, SyscallHandler, SyscallTable};

    struct TestHandler;
    impl SyscallHandler for TestHandler {
        fn handle(&self, _args: &[u64]) -> VmResult<u64> {
            Ok(42)
        }
    }

    let mut table = SyscallTable::new();
    table.register(1, Box::new(TestHandler));

    let result = table.execute(1, &[]);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 42);
}

#[test]
fn test_syscall_not_found() {
    use vm_core::syscall::{Syscall, SyscallTable};
    let table = SyscallTable::new();

    let result = table.execute(999, &[]);
    assert!(result.is_err());
}

#[test]
fn test_syscall_with_arguments() {
    use vm_core::syscall::{Syscall, SyscallHandler, SyscallTable};

    struct AddHandler;
    impl SyscallHandler for AddHandler {
        fn handle(&self, args: &[u64]) -> VmResult<u64> {
            Ok(args.get(0).unwrap_or(&0) + args.get(1).unwrap_or(&0))
        }
    }

    let mut table = SyscallTable::new();
    table.register(1, Box::new(AddHandler));

    let result = table.execute(1, &[10, 20]);
    assert!(result.is_ok());
    assert_eq!(result.unwrap(), 30);
}

// ============================================================================
// GuestAddr Comprehensive Tests
// ============================================================================

#[test]
fn test_guest_addr_alignment_edge_cases() {
    // Test with alignment of 1
    let addr = GuestAddr(0x1001);
    assert!(addr.is_aligned(1));

    // Test with power of 2 alignments
    let addr = GuestAddr(0x1000);
    for align in [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096] {
        assert!(addr.is_aligned(align));
    }

    // Test edge case: maximum alignment (page size)
    let addr = GuestAddr(0x1000);
    let aligned = addr.align_down(4096);
    assert_eq!(aligned.0, 0x1000);

    let addr = GuestAddr(0x1FFF);
    let aligned = addr.align_down(4096);
    assert_eq!(aligned.0, 0x0);
}

#[test]
fn test_guest_addr_arithmetic_overflow() {
    let addr = GuestAddr(u64::MAX);
    let result = addr + 1;
    assert_eq!(result.0, 0);

    let addr = GuestAddr(0);
    let result = addr - 1;
    assert_eq!(result.0, u64::MAX);
}

#[test]
fn test_guest_addr_range_check() {
    let base = GuestAddr(0x1000);
    let size = 0x100;

    assert!(base.0.checked_add(size).is_some());

    let overflow_addr = GuestAddr(u64::MAX);
    assert!(overflow_addr.0.checked_add(1).is_none());
}

// ============================================================================
// GuestVAddr Comprehensive Tests
// ============================================================================

#[test]
fn test_guest_vaddr_comprehensive() {
    let vaddr1 = GuestVAddr(0x1000);
    let vaddr2 = GuestVAddr(0x2000);

    // Test conversion
    let gaddr1: GuestAddr = vaddr1.into();
    assert_eq!(gaddr1.0, 0x1000);

    // Test arithmetic
    let result = vaddr1 + 0x100;
    assert_eq!(result.0, 0x1100);

    let result = vaddr2 - 0x100;
    assert_eq!(result.0, 0x1F00);

    // Test alignment
    let vaddr = GuestVAddr(0x1003);
    let aligned = vaddr.align_down(4);
    assert_eq!(aligned.0, 0x1000);

    assert!(GuestVAddr(0x1000).is_aligned(4));
    assert!(!GuestVAddr(0x1001).is_aligned(4));
}

// ============================================================================
// HostPtr Comprehensive Tests
// ============================================================================

#[test]
fn test_host_ptr_comprehensive() {
    // Test null pointer
    let null_ptr = HostPtr::<u8>::null();
    assert!(null_ptr.is_null());

    // Test from raw pointer
    let value = 42u8;
    let ptr = HostPtr::from(&value as *const u8);
    assert!(!ptr.is_null());

    // Test as_ptr
    let raw_ptr = ptr.as_ptr();
    assert_eq!(unsafe { *raw_ptr }, 42);

    // Test mut pointer
    let mut value = 10u8;
    let mut_ptr = HostPtr::from(&mut value as *mut u8);
    unsafe {
        *mut_ptr.as_mut_ptr() = 20;
    }
    assert_eq!(value, 20);

    // Test with different types
    let array = [1u32, 2, 3, 4];
    let ptr = HostPtr::from(array.as_ptr());
    assert_eq!(unsafe { *ptr.as_ptr() }, 1);

    // Test offset
    let second = unsafe { *ptr.as_ptr().add(1) };
    assert_eq!(second, 2);
}

// ============================================================================
// VmError Tests
// ============================================================================

#[test]
fn test_vm_error_display() {
    let err = VmError::InvalidAddress(GuestAddr(0x1000));
    let display = format!("{}", err);
    assert!(display.contains("0x1000"));
}

#[test]
fn test_vm_error_debug() {
    let err = VmError::InvalidAddress(GuestAddr(0x1000));
    let debug = format!("{:?}", err);
    assert!(debug.contains("InvalidAddress"));
}

#[test]
fn test_vm_error_from_io() {
    use std::io;
    let io_err = io::Error::new(io::ErrorKind::NotFound, "test");
    let vm_err: VmError = io_err.into();
    assert!(matches!(vm_err, VmError::Io(_)));
}

// ============================================================================
// PageTableEntry Tests
// ============================================================================

// #[test]
// fn test_page_table_entry_creation() {
//     let entry = PageTableEntry::new(0x1000);
//     assert_eq!(entry.address(), 0x1000);
// }
// 
// #[test]
// fn test_page_table_entry_flags() {
//     let mut entry = PageTableEntry::new(0x1000);
// 
//     entry.set_present(true);
//     assert!(entry.is_present());
// 
//     entry.set_writable(true);
//     assert!(entry.is_writable());
// 
//     entry.set_user_accessible(true);
//     assert!(entry.is_user_accessible());
// 
//     entry.set_accessed(true);
//     assert!(entry.was_accessed());
// 
//     entry.set_dirty(true);
//     assert!(entry.is_dirty());
// }
// 
// #[test]
// fn test_page_table_entry_large_page() {
//     let entry = PageTableEntry::new(0x1000);
//     assert!(!entry.is_large_page());
// 
//     let mut entry = PageTableEntry::new(0x1000);
//     entry.set_large_page(true);
//     assert!(entry.is_large_page());
// }
// 
// #[test]
// fn test_page_table_entry_no_execute() {
//     let mut entry = PageTableEntry::new(0x1000);
//     entry.set_no_execute(true);
//     assert!(entry.is_no_execute());
// }

// ============================================================================
// MMU Trait Basic Tests
// ============================================================================

#[test]
fn test_mmu_trait_basic() {
    // This is a compile-time test for the MMU trait
    // Actual implementations would be in integration tests

    use vm_core::MMU;

    struct DummyMmu;
    impl MMU for DummyMmu {
        fn read_byte(&mut self, _addr: GuestAddr) -> VmResult<u8> {
            Ok(0)
        }

        fn write_byte(&mut self, _addr: GuestAddr, _value: u8) -> VmResult<()> {
            Ok(())
        }

        fn read_bytes(&mut self, _addr: GuestAddr, _buf: &mut [u8]) -> VmResult<()> {
            Ok(())
        }

        fn write_bytes(&mut self, _addr: GuestAddr, _data: &[u8]) -> VmResult<()> {
            Ok(())
        }
    }

    let mut mmu = DummyMmu;
    assert!(mmu.read_byte(GuestAddr(0)).is_ok());
    assert!(mmu.write_byte(GuestAddr(0), 42).is_ok());
}

// ============================================================================
// AggregateRoot Tests
// ============================================================================

#[test]
fn test_aggregate_root_creation() {
    use vm_core::AggregateRoot;
    let root = AggregateRoot::new("test-root".to_string());
    assert_eq!(root.id(), "test-root");
    assert_eq!(root.version(), 0);
}

#[test]
fn test_aggregate_root_events() {
    use vm_core::AggregateRoot;

    let mut root = AggregateRoot::new("test-root".to_string());
    assert!(!root.has_uncommitted_events());
    assert_eq!(root.uncommitted_events().count(), 0);
}

#[test]
fn test_aggregate_root_version_increment() {
    use vm_core::AggregateRoot;

    let mut root = AggregateRoot::new("test-root".to_string());
    root.increment_version();
    assert_eq!(root.version(), 1);
}

// ============================================================================
// EventStore Trait Tests
// ============================================================================

#[test]
fn test_in_memory_event_store_comprehensive() {
    use vm_core::event_sourcing::{Event, EventId, EventMetadata, EventStore};

    #[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
    struct TestEvent {
        id: EventId,
        metadata: EventMetadata,
    }

    impl TestEvent {
        fn new() -> Self {
            Self {
                id: EventId::new(),
                metadata: EventMetadata::new(),
            }
        }
    }

    impl Event for TestEvent {
        fn event_type(&self) -> &str {
            "TestEvent"
        }

        fn metadata(&self) -> &EventMetadata {
            &self.metadata
        }
    }

    let store = InMemoryEventStore::new();

    // Test append
    let event1 = TestEvent::new();
    store.append_event(event1).unwrap();

    // Test get
    let all = store.get_all_events().unwrap();
    assert_eq!(all.len(), 1);

    // Test clear
    store.clear();
    let all = store.get_all_events().unwrap();
    assert_eq!(all.len(), 0);
}

// ============================================================================
// Domain Events Tests
// ============================================================================

#[test]
fn test_domain_events() {
    use vm_core::domain_events::DomainEvent;

    let event = DomainEvent::new("test-event".to_string());
    assert_eq!(event.event_type(), "test-event");
    assert_eq!(event.version(), 1);
}

#[test]
fn test_domain_events_with_metadata() {
    use vm_core::domain_events::DomainEvent;

    let event =
        DomainEvent::new("test-event".to_string()).with_correlation_id("corr-123".to_string());

    assert_eq!(event.correlation_id(), Some("corr-123"));
}
