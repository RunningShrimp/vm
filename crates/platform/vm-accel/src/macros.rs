//! Macros for generating repetitive platform code
//!
//! This module provides declarative macros to reduce code duplication
//! in platform-specific implementations. Instead of writing the same
//! register access patterns multiple times for different architectures,
//! we use macros to generate the code.
//!
//! # Example
//!
//! ```rust,ignore
//! use vm_accel::macros::{impl_reg_accessors, reg_map};
//!
//! // Define register mapping for x86_64
//! impl_reg_accessors!(
//!     KvmVcpuX86_64,
//!     kvm_get_reg,
//!     kvm_set_reg,
//!     reg_map!(
//!         0 => RAX,
//!         1 => RCX,
//!         2 => RDX,
//!         // ... all 16 GPRs
//!     )
//! );
//! ```

/// Macro to generate register accessor implementations
///
/// This macro generates `get_regs()` and `set_regs()` implementations
/// for vCPU types, eliminating the need to manually write repetitive
/// register mapping code.
///
/// # Arguments
///
/// * `$platform_type` - The vCPU type (e.g., `KvmVcpuX86_64`)
/// * `$get_reg_fn` - Function to get a single register
/// * `$set_reg_fn` - Function to set a single register
/// * `$reg_map` - Register mapping defined by `reg_map!` macro
///
/// # Example
///
/// ```rust,ignore
/// use vm_accel::macros::{impl_reg_accessors, reg_map};
/// use vm_core::GuestRegs;
/// use vm_accel::vcpu_common::VcpuResult;
///
/// // For KVM x86_64
/// impl_reg_accessors!(
///     KvmVcpuX86_64,
///     kvm_get_reg,
///     kvm_set_reg,
///     reg_map!(
///         0 => RAX,
///         1 => RCX,
///         2 => RDX,
///         3 => RBX,
///         4 => RSP,
///         5 => RBP,
///         6 => RSI,
///         7 => RDI,
///         8 => R8,
///         9 => R9,
///         10 => R10,
///         11 => R11,
///         12 => R12,
///         13 => R13,
///         14 => R14,
///         15 => R15
///     )
/// );
/// ```
///
/// # Generated Code
///
/// The macro expands to implementations of `get_regs()` and `set_regs()`
/// that iterate over the register map and perform the appropriate
/// platform-specific calls.
#[macro_export]
macro_rules! impl_reg_accessors {
    (
        $platform_type:ty,
        $get_reg_fn:ident,
        $set_reg_fn:ident,
        $reg_map:expr
    ) => {
        impl $platform_type {
            /// Get all general-purpose registers
            ///
            /// This method is auto-generated by the `impl_reg_accessors!` macro.
            /// It reads each register according to the register map.
            pub fn get_regs_mapped(&self) -> $crate::vcpu_common::VcpuResult<vm_core::GuestRegs> {
                use vm_core::GuestRegs;

                let mut gpr = [0u64; 32];

                // Iterate over register map and read each register
                for reg_mapping in $reg_map {
                    let value = unsafe {
                        let mut val = 0u64;
                        // Call platform-specific get function
                        self.$get_reg_fn(reg_mapping.kvm_reg, &mut val)
                            .map_err(|e| {
                                vm_core::VmError::Platform(vm_core::PlatformError::AccessDenied(
                                    format!("Failed to get register: {}", e),
                                ))
                            })?;
                        val
                    };
                    gpr[reg_mapping.index] = value;
                }

                // Note: PC, SP, FP are set to 0 by default.
                // Architecture-specific implementations should override
                // this method to provide actual register values if needed.
                Ok(GuestRegs {
                    pc: 0,
                    sp: 0,
                    fp: 0,
                    gpr,
                })
            }

            /// Set all general-purpose registers
            ///
            /// This method is auto-generated by the `impl_reg_accessors!` macro.
            /// It writes each register according to the register map.
            pub fn set_regs_mapped(
                &mut self,
                regs: &vm_core::GuestRegs,
            ) -> $crate::vcpu_common::VcpuResult<()> {
                // Iterate over register map and write each register
                for reg_mapping in $reg_map {
                    unsafe {
                        // Call platform-specific set function
                        self.$set_reg_fn(reg_mapping.kvm_reg, regs.gpr[reg_mapping.index])
                            .map_err(|e| {
                                vm_core::VmError::Platform(vm_core::PlatformError::AccessDenied(
                                    format!("Failed to set register: {}", e),
                                ))
                            })?;
                    }
                }

                // Note: PC, SP, FP are not set here.
                // Architecture-specific implementations should override
                // this method to set these registers if needed.
                Ok(())
            }
        }
    };
}

/// Register mapping definition
///
/// This macro creates an array of register mappings, where each mapping
/// associates an index in the `gpr` array with a platform-specific
/// register identifier.
///
/// # Arguments
///
/// * `$idx` - Index in the gpr array (0-31)
/// * `$kvm_reg` - Platform-specific register constant
///
/// # Example
///
/// ```rust,ignore
/// use vm_accel::macros::reg_map;
///
/// let x86_64_gpr_map = reg_map!(
///     0 => RAX,
///     1 => RCX,
///     2 => RDX,
///     // ... etc
/// );
/// ```
///
/// # Output Type
///
/// Returns a `&'static [RegMapping]` where `RegMapping` is:
///
/// ```rust,ignore
/// struct RegMapping {
///     index: usize,
///     kvm_reg: u64, // or platform-specific type
/// }
/// ```
#[macro_export]
macro_rules! reg_map {
    (
        $($idx:expr => $kvm_reg:expr),* $(,)?
    ) => {
        &[
            $(
                $crate::macros::RegMapping {
                    index: $idx,
                    kvm_reg: $kvm_reg,
                }
            ),*
        ]
    };
}

/// Register mapping structure
///
/// Used internally by the `reg_map!` macro to associate
/// gpr array indices with platform-specific register IDs.
#[derive(Debug, Clone, Copy)]
pub struct RegMapping {
    /// Index in the gpr array
    pub index: usize,
    /// Platform-specific register identifier
    pub kvm_reg: u64,
}

/// Macro to generate vCPU creation implementations
///
/// This macro generates the `new()` method for vCPU types, reducing
/// duplication across different platforms and architectures.
///
/// # Arguments
///
/// * `$vcpu_type` - The vCPU type (e.g., `KvmVcpuX86_64`)
/// * `$vm_type` - The VM/Fd type (e.g., `VmFd`)
/// * `$mmap_size_fn` - Function to get mmap size
///
/// # Example
///
/// ```rust,ignore
/// use vm_accel::macros::impl_vcpu_new;
///
/// impl_vcpu_new!(KvmVcpuX86_64, VmFd, get_vcpu_mmap_size);
/// ```
#[macro_export]
macro_rules! impl_vcpu_new {
    (
        $vcpu_type:ty,
        $vm_type:ty,
        $mmap_size_fn:ident
    ) => {
        impl $vcpu_type {
            /// Create a new vCPU
            ///
            /// This method is auto-generated by the `impl_vcpu_new!` macro.
            pub fn new(vm: &$vm_type, id: u32) -> $crate::vcpu_common::VcpuResult<Self> {
                use vm_core::VmError;

                // Create vCPU
                let vcpu = vm.create_vcpu(id as u64).map_err(|e| {
                    VmError::Platform(vm_core::PlatformError::ResourceAllocationFailed(format!(
                        "Platform create_vcpu failed: {}",
                        e
                    )))
                })?;

                // Get mmap size
                let run_mmap_size = vm.$mmap_size_fn().map_err(|e| {
                    VmError::Platform(vm_core::PlatformError::ResourceAllocationFailed(format!(
                        "Failed to get mmap size: {}",
                        e
                    )))
                })?;

                Ok(Self {
                    fd: vcpu,
                    id,
                    run_mmap_size,
                })
            }
        }
    };
}

/// Simplified macro for vCPU creation without mmap_size
///
/// Use this for platforms that don't require mmap_size (e.g., WHPX, VZ)
#[macro_export]
macro_rules! impl_vcpu_new_simple {
    (
        $vcpu_type:ty,
        $vm_type:ty,
        $create_fn:ident
    ) => {
        impl $vcpu_type {
            /// Create a new vCPU (simplified version)
            ///
            /// This method is auto-generated by the `impl_vcpu_new_simple!` macro.
            pub fn new(vm: &$vm_type, id: u32) -> $crate::vcpu_common::VcpuResult<Self> {
                use vm_core::VmError;

                let vcpu = vm.$create_fn(id).map_err(|e| {
                    VmError::Platform(vm_core::PlatformError::ResourceAllocationFailed(format!(
                        "Platform vCPU creation failed: {}",
                        e
                    )))
                })?;

                Ok(Self {
                    fd: vcpu,
                    id,
                    run_mmap_size: 0, // Not used for this platform
                })
            }
        }
    };
}

/// Macro to generate platform backend selection
///
/// This macro generates the `select()` function that automatically
/// detects and initializes the best available hardware acceleration.
///
/// # Example
///
/// ```rust,ignore
/// use vm_accel::macros::impl_platform_select;
/// use vm_accel::{AccelKind, PlatformBackend};
///
/// impl_platform_select! {
///     linux => Kvm,
///     macos => Hvf,
///     windows => Whpx
/// }
/// ```
#[macro_export]
macro_rules! impl_platform_select {
    (
        $($os:literal => $backend:ident),* $(,)?
    ) => {
        /// Automatically select the best available hardware acceleration
        ///
        /// This function is auto-generated by the `impl_platform_select!` macro.
        pub fn select_platform() -> ($crate::AccelKind, Box<dyn $crate::Accel>) {
            $(
                #[cfg(target_os = $os)]
                {
                    let mut a = stringify!($backend).to_lowercase();
                    // Try to initialize backend
                    // Implementation depends on platform
                }
            )*

            #[allow(unreachable_code)]
            ($crate::AccelKind::None, Box::new(crate::NoAccel))
        }
    };
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_reg_map_macro() {
        let map = reg_map!(
            0 => 0x1000,
            1 => 0x1001,
            2 => 0x1002,
        );

        assert_eq!(map.len(), 3);
        assert_eq!(map[0].index, 0);
        assert_eq!(map[0].kvm_reg, 0x1000);
        assert_eq!(map[1].index, 1);
        assert_eq!(map[1].kvm_reg, 0x1001);
    }

    #[test]
    fn test_reg_mapping_clone() {
        let mapping = RegMapping {
            index: 5,
            kvm_reg: 0xDEAD_BEEF,
        };

        let cloned = mapping;
        assert_eq!(cloned.index, 5);
        assert_eq!(cloned.kvm_reg, 0xDEAD_BEEF);
    }
}
