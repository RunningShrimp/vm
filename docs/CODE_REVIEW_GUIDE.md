# ä»£ç å®¡æŸ¥æŒ‡å—

æœ¬æŒ‡å—ä¸ºVMé¡¹ç›®çš„ä»£ç å®¡æŸ¥è€…ï¼ˆreviewerï¼‰å’Œè¢«å®¡æŸ¥è€…ï¼ˆauthorï¼‰æä¾›æœ€ä½³å®è·µã€‚

## ç›®å½•

- [å®¡æŸ¥åŸåˆ™](#å®¡æŸ¥åŸåˆ™)
- [å®¡æŸ¥æµç¨‹](#å®¡æŸ¥æµç¨‹)
- [å®¡æŸ¥é‡ç‚¹](#å®¡æŸ¥é‡ç‚¹)
- [å¸¸è§é—®é¢˜](#å¸¸è§é—®é¢˜)
- [åé¦ˆæŠ€å·§](#åé¦ˆæŠ€å·§)
- [æ‰¹å‡†æ ‡å‡†](#æ‰¹å‡†æ ‡å‡†)

## å®¡æŸ¥åŸåˆ™

### æ ¸å¿ƒä»·å€¼

1. **è´¨é‡ä¼˜å…ˆ**ï¼šç¡®ä¿ä»£ç è´¨é‡
2. **çŸ¥è¯†åˆ†äº«**ï¼šé€šè¿‡å®¡æŸ¥ä¼ æ’­çŸ¥è¯†
3. **å›¢é˜Ÿæˆé•¿**ï¼šå¸®åŠ©è´¡çŒ®è€…æˆé•¿
4. **æ•ˆç‡å¹³è¡¡**ï¼šè´¨é‡ä¸æ•ˆç‡çš„å¹³è¡¡

### å®¡æŸ¥å¿ƒæ€

**ä½œä¸ºå®¡æŸ¥è€…**ï¼š

- âœ… å»ºè®¾æ€§åé¦ˆ
- âœ… å°Šé‡å’Œç¤¼è²Œ
- âœ… è§£é‡ŠåŸå› 
- âœ… æ‰¿è®¤ä¼˜ç‚¹
- âœ… çµæ´»å¼€æ”¾

**é¿å…**ï¼š
- âŒ å‘½ä»¤å¼è¯­è¨€
- âŒ ä¸ªäººæ”»å‡»
- âŒ å®Œç¾ä¸»ä¹‰
- âŒ æ‹–å»¶å®¡æŸ¥

### å®¡æŸ¥ç›®æ ‡

- **æ­£ç¡®æ€§**ï¼šä»£ç æ˜¯å¦æ­£ç¡®å®ç°åŠŸèƒ½
- **è´¨é‡**ï¼šä»£ç æ˜¯å¦æ˜“äºç»´æŠ¤
- **ä¸€è‡´æ€§**ï¼šæ˜¯å¦ç¬¦åˆé¡¹ç›®è§„èŒƒ
- **å®‰å…¨**ï¼šæ˜¯å¦å­˜åœ¨å®‰å…¨é£é™©
- **æ€§èƒ½**ï¼šæ˜¯å¦æœ‰æ€§èƒ½é—®é¢˜

## å®¡æŸ¥æµç¨‹

### å®¡æŸ¥é˜¶æ®µ

#### 1. åˆæ­¥å®¡æŸ¥ï¼ˆ5-10åˆ†é’Ÿï¼‰

**ç›®æ ‡**ï¼šå¿«é€Ÿäº†è§£PRçš„ç›®çš„

- é˜…è¯»PRæè¿°
- æŸ¥çœ‹å˜æ›´æ–‡ä»¶åˆ—è¡¨
- ç†è§£å˜æ›´çš„åŠ¨æœº
- æ£€æŸ¥CIçŠ¶æ€

```
CIé€šè¿‡äº†å—ï¼Ÿ
â”œâ”€â”€ æ˜¯ â†’ ç»§ç»­ä»£ç å®¡æŸ¥
â””â”€â”€ å¦ â†’ ç­‰å¾…CIé€šè¿‡æˆ–å¸®åŠ©ä¿®å¤
```

#### 2. ä»£ç å®¡æŸ¥ï¼ˆ20-40åˆ†é’Ÿï¼‰

**ç›®æ ‡**ï¼šè¯¦ç»†å®¡æŸ¥ä»£ç å˜æ›´

**å®¡æŸ¥é¡ºåº**ï¼š

1. **å…¬å…±API**ï¼ˆå¦‚æœæœ‰ï¼‰
   - APIè®¾è®¡æ˜¯å¦åˆç†
   - æ–‡æ¡£æ˜¯å¦å®Œæ•´
   - å‘åå…¼å®¹æ€§

2. **æ ¸å¿ƒå®ç°**
   - ç®—æ³•å’Œé€»è¾‘
   - é”™è¯¯å¤„ç†
   - è¾¹ç•Œæ¡ä»¶

3. **æµ‹è¯•**
   - æµ‹è¯•è¦†ç›–ç‡
   - æµ‹è¯•è´¨é‡
   - è¾¹ç•Œæƒ…å†µ

4. **æ–‡æ¡£**
   - æ›´æ–°æ˜¯å¦å®Œæ•´
   - ç¤ºä¾‹æ˜¯å¦æ­£ç¡®

#### 3. åé¦ˆå’Œè¿­ä»£ï¼ˆ30åˆ†é’Ÿ-æ•°å°æ—¶ï¼‰

**ç›®æ ‡**ï¼šæä¾›åé¦ˆå¹¶è·Ÿè¿›ä¿®æ”¹

- æå‡ºé—®é¢˜å’Œå»ºè®®
- è®¨è®ºè®¾è®¡æ–¹æ¡ˆ
- ç­‰å¾…ä½œè€…ä¿®æ”¹
- éªŒè¯ä¿®æ”¹

#### 4. æ‰¹å‡†å’Œåˆå¹¶ï¼ˆ5åˆ†é’Ÿï¼‰

**ç›®æ ‡**ï¼šæœ€ç»ˆå†³å®š

- ç¡®è®¤æ‰€æœ‰é—®é¢˜è§£å†³
- ç»™äºˆæ‰¹å‡†ï¼ˆApprovalï¼‰
- åˆå¹¶æˆ–ç­‰å¾…å…¶ä»–å®¡æŸ¥è€…

### å®¡æŸ¥é€Ÿåº¦

**é¢„æœŸå“åº”æ—¶é—´**ï¼š

| PRç±»å‹ | ç›®æ ‡å“åº”æ—¶é—´ | æœ€å¤§å“åº”æ—¶é—´ |
|--------|-------------|-------------|
| ç´§æ€¥ä¿®å¤ | 4å°æ—¶ | 1å¤© |
| æ–°åŠŸèƒ½ | 2å¤© | 5å¤© |
| é‡æ„ | 3å¤© | 7å¤© |
| æ–‡æ¡£ | 2å¤© | 5å¤© |

**ä½œä¸ºä½œè€…**ï¼š
- ç­‰å¾…3-5å¤©åå¯ä»¥å‹å¥½æé†’
- é¿å…é¢‘ç¹@æåŠ

**ä½œä¸ºå®¡æŸ¥è€…**ï¼š
- è®¾ç½®åˆç†çš„æœŸæœ›
- å¦‚æœç¹å¿™ï¼Œå‘ŠçŸ¥é¢„è®¡æ—¶é—´
- å¯ä»¥è¯·æ±‚å…¶ä»–å®¡æŸ¥è€…å¸®åŠ©

## å®¡æŸ¥é‡ç‚¹

### 1. æ­£ç¡®æ€§

#### åŠŸèƒ½æ­£ç¡®æ€§

**æ£€æŸ¥è¦ç‚¹**ï¼š

- [ ] å®ç°ç¬¦åˆéœ€æ±‚æè¿°
- [ ] è¾¹ç•Œæ¡ä»¶å¤„ç†
- [ ] é”™è¯¯æƒ…å†µå¤„ç†
- [ ] å¹¶å‘å®‰å…¨æ€§ï¼ˆå¦‚é€‚ç”¨ï¼‰

**ç¤ºä¾‹å®¡æŸ¥**ï¼š

```rust
// âš ï¸ æ½œåœ¨é—®é¢˜ï¼šæ²¡æœ‰æ£€æŸ¥æº¢å‡º
pub fn allocate(size: usize) -> Result<usize> {
    self.next_addr += size;  // å¯èƒ½æº¢å‡º
    Ok(self.next_addr - size)
}

// âœ… æ”¹è¿›ï¼šæ£€æŸ¥æº¢å‡º
pub fn allocate(size: usize) -> Result<usize> {
    let new_addr = self.next_addr.checked_add(size)
        .ok_or(Error::OutOfMemory)?;
    self.next_addr = new_addr;
    Ok(new_addr - size)
}
```

#### å•å…ƒæµ‹è¯•

**æ£€æŸ¥è¦ç‚¹**ï¼š

- [ ] æµ‹è¯•è¦†ç›–ä¸»è¦åŠŸèƒ½
- [ ] æµ‹è¯•è¾¹ç•Œæƒ…å†µ
- [ ] æµ‹è¯•é”™è¯¯è·¯å¾„
- [ ] æµ‹è¯•å¯è¯»æ€§

**ç¤ºä¾‹**ï¼š

```rust
// âŒ æµ‹è¯•ä¸è¶³
#[test]
fn test_read() {
    assert_eq!(read(0), 42);
}

// âœ… å®Œæ•´æµ‹è¯•
#[test]
fn test_read_success() {
    assert_eq!(read(0), 42);
}

#[test]
fn test_read_invalid_address() {
    assert!(read(9999).is_err());
}

#[test]
fn test_read_after_write() {
    write(0, 100);
    assert_eq!(read(0), 100);
}
```

### 2. ä»£ç è´¨é‡

#### å¯è¯»æ€§

**æ£€æŸ¥è¦ç‚¹**ï¼š

- [ ] å‘½åæ¸…æ™°æœ‰æ„ä¹‰
- [ ] å‡½æ•°èŒè´£å•ä¸€
- [ ] é€»è¾‘æ¸…æ™°æ˜“æ‡‚
- [ ] é¿å…å¤æ‚çš„åµŒå¥—

**ç¤ºä¾‹**ï¼š

```rust
// âŒ éš¾ä»¥ç†è§£
fn p(a: u64, b: u64) -> bool {
    if a > 0 { if b > 0 { a + b > 100 } else { false } } else { false }
}

// âœ… æ¸…æ™°æ˜äº†
fn is_large_sum(a: u64, b: u64) -> bool {
    // æ£€æŸ¥ä¸¤ä¸ªæ­£æ•°ä¹‹å’Œæ˜¯å¦å¤§äº100
    a > 0 && b > 0 && a + b > 100
}
```

#### ç®€æ´æ€§

**æ£€æŸ¥è¦ç‚¹**ï¼š

- [ ] é¿å…é‡å¤ä»£ç 
- [ ] ä½¿ç”¨ç°æœ‰çš„åº“å‡½æ•°
- [ ] åˆç†çš„æŠ½è±¡

**ç¤ºä¾‹**ï¼š

```rust
// âŒ é‡å¤ä»£ç 
let v1 = vec![1, 2, 3];
let mut v2 = Vec::new();
for i in &v1 {
    v2.push(i * 2);
}

// âœ… ä½¿ç”¨è¿­ä»£å™¨
let v1 = vec![1, 2, 3];
let v2: Vec<_> = v1.iter().map(|i| i * 2).collect();
```

### 3. Rustç‰¹å®š

#### é”™è¯¯å¤„ç†

**æ£€æŸ¥è¦ç‚¹**ï¼š

- [ ] ä½¿ç”¨Resultè€Œépanic
- [ ] æä¾›æœ‰æ„ä¹‰çš„é”™è¯¯ä¿¡æ¯
- [ ] é¿å…unwrap()ï¼ˆç¡®å®šçš„æƒ…å†µä¸‹é™¤å¤–ï¼‰

**ç¤ºä¾‹**ï¼š

```rust
// âŒ ä½¿ç”¨unwrap
pub fn read(&self, addr: u64) -> u8 {
    self.memory.get(addr).unwrap()
}

// âœ… æ­£ç¡®çš„é”™è¯¯å¤„ç†
pub fn read(&self, addr: u64) -> Result<u8, MemoryError> {
    self.memory.get(addr)
        .copied()
        .ok_or(MemoryError::InvalidAddress { addr })
}
```

#### å¹¶å‘å®‰å…¨

**æ£€æŸ¥è¦ç‚¹**ï¼š

- [ ] æ­£ç¡®ä½¿ç”¨Arc/Mutex
- [ ] é¿å…æ­»é”
- [ ] è€ƒè™‘æ€§èƒ½å½±å“

**ç¤ºä¾‹**ï¼š

```rust
// âš ï¸ å¯èƒ½æ­»é”
fn transfer(a: &Mutex<Account>, b: &Mutex<Account>, amount: u64) {
    let _a = a.lock().unwrap();
    let _b = b.lock().unwrap();  // å¯èƒ½æ­»é”
    // ...
}

// âœ… é¿å…æ­»é”
fn transfer(a: &Mutex<Account>, b: &Mutex<Account>, amount: u64) {
    // æ€»æ˜¯å…ˆé”è¾ƒå°çš„åœ°å€
    let (first, second) = if a.as_ptr() < b.as_ptr() {
        (a, b)
    } else {
        (b, a)
    };
    let _a = first.lock().unwrap();
    let _b = second.lock().unwrap();
    // ...
}
```

#### Unsafeä»£ç 

**æ£€æŸ¥è¦ç‚¹**ï¼š

- [ ] å¿…é¡»æœ‰è¯¦ç»†æ³¨é‡Šè¯´æ˜å®‰å…¨æ€§
- [ ] ä¼˜å…ˆè€ƒè™‘å®‰å…¨æ›¿ä»£æ–¹æ¡ˆ
- [ ] é¢å¤–å®¡æŸ¥

**ç¤ºä¾‹**ï¼š

```rust
// âœ… Unsafeä»£ç æœ‰è¯¦ç»†è¯´æ˜
/// # Safety
///
/// è°ƒç”¨è€…å¿…é¡»ç¡®ä¿ï¼š
/// - `ptr` æ˜¯æœ‰æ•ˆä¸”å¯¹é½çš„
/// - `ptr` æŒ‡å‘çš„å†…å­˜è‡³å°‘æœ‰ `len` ä¸ªå…ƒç´ 
/// - åœ¨æ­¤å‡½æ•°æ‰§è¡ŒæœŸé—´ï¼Œæ²¡æœ‰å…¶ä»–ä»£ç è®¿é—®è¯¥å†…å­˜
pub unsafe fn read_slice(ptr: *const u8, len: usize) -> Vec<u8> {
    // SAFETY: è°ƒç”¨è€…å·²æ»¡è¶³æ‰€æœ‰å®‰å…¨æ¡ä»¶
    std::slice::from_raw_parts(ptr, len).to_vec()
}
```

### 4. æ€§èƒ½

**æ£€æŸ¥è¦ç‚¹**ï¼š

- [ ] é¿å…ä¸å¿…è¦çš„å…‹éš†
- [ ] åˆç†ä½¿ç”¨é›†åˆç±»å‹
- [ ] æ³¨æ„ç®—æ³•å¤æ‚åº¦
- [ ] I/Oä¼˜åŒ–

**ç¤ºä¾‹**ï¼š

```rust
// âŒ ä¸å¿…è¦çš„å…‹éš†
pub fn process(data: Vec<u8>) -> Vec<u8> {
    let cloned = data.clone();  // ä¸å¿…è¦çš„å…‹éš†
    transform(cloned)
}

// âœ… é¿å…å…‹éš†
pub fn process(data: Vec<u8>) -> Vec<u8> {
    transform(data)
}

// æˆ–ä½¿ç”¨å¼•ç”¨
pub fn process(data: &[u8]) -> Vec<u8> {
    transform(data.to_vec())
}
```

**æ€§èƒ½å®¡æŸ¥å·¥å…·**ï¼š

```bash
# Benchmark
cargo bench --bench name

# Flamegraph
cargo install flamegraph
cargo flamegraph --bench name
```

### 5. å®‰å…¨æ€§

**æ£€æŸ¥è¦ç‚¹**ï¼š

- [ ] è¾“å…¥éªŒè¯
- [ ] æ•´æ•°æº¢å‡ºæ£€æŸ¥
- [ ] å†…å­˜å®‰å…¨
- [ ] æ•æ„Ÿæ•°æ®å¤„ç†

**ç¤ºä¾‹**ï¼š

```rust
// âš ï¸ æ²¡æœ‰éªŒè¯
pub fn execute(code: &[u8]) {
    for instr in code {
        // ç›´æ¥æ‰§è¡Œï¼Œæ²¡æœ‰éªŒè¯
    }
}

// âœ… æ·»åŠ éªŒè¯
pub fn execute(code: &[u8]) -> Result<()> {
    if code.len() > MAX_CODE_SIZE {
        return Err(Error::CodeTooLarge);
    }

    for instr in code {
        validate_instruction(instr)?;
    }
    // ...
}
```

### 6. æ–‡æ¡£

**æ£€æŸ¥è¦ç‚¹**ï¼š

- [ ] å…¬å…±APIæœ‰æ–‡æ¡£æ³¨é‡Š
- [ ] å¤æ‚é€»è¾‘æœ‰è¯´æ˜æ³¨é‡Š
- [ ] ç¤ºä¾‹ä»£ç æ­£ç¡®
- [ ] CHANGELOGæ›´æ–°

**ç¤ºä¾‹**ï¼š

```rust
// âŒ ç¼ºå°‘æ–‡æ¡£
pub fn map_page(&mut self, virt: u64, phys: u64, flags: u32) -> Result<()> {
    // ...
}

// âœ… å®Œæ•´æ–‡æ¡£
/// æ˜ å°„è™šæ‹Ÿé¡µåˆ°ç‰©ç†é¡µ
///
/// å°†è™šæ‹Ÿåœ°å€`virt`å¼€å§‹çš„é¡µé¢æ˜ å°„åˆ°ç‰©ç†åœ°å€`phys`ã€‚
///
/// # å‚æ•°
///
/// - `virt`: è™šæ‹Ÿåœ°å€ï¼ˆå¿…é¡»é¡µå¯¹é½ï¼‰
/// - `phys`: ç‰©ç†åœ°å€ï¼ˆå¿…é¡»é¡µå¯¹é½ï¼‰
/// - `flags`: é¡µé¢æ ‡å¿—ï¼ˆè¯»/å†™/æ‰§è¡Œæƒé™ï¼‰
///
/// # é”™è¯¯
///
/// - `Error::Unaligned`: åœ°å€æœªå¯¹é½
/// - `Error::OutOfMemory`: é¡µè¡¨å†…å­˜ä¸è¶³
///
/// # ç¤ºä¾‹
///
/// ```
/// # use vm_mm::MMU;
/// let mut mmu = MMU::new();
/// mmu.map_page(0x1000, 0x2000, PageFlags::RW)?;
/// # Ok::<(), Box<dyn std::error::Error>>(())
/// ```
pub fn map_page(&mut self, virt: u64, phys: u64, flags: u32) -> Result<()> {
    // ...
}
```

## å¸¸è§é—®é¢˜

### å‘½åé—®é¢˜

| é—®é¢˜ | ç¤ºä¾‹ | å»ºè®® |
|-----|------|------|
| å¤ªçŸ­ | `fn p()` | ä½¿ç”¨å®Œæ•´å•è¯ |
| ç¼©å†™è¿‡å¤š | `virt_addr_tbl` | `page_table` |
| ä¸ä¸€è‡´ | `read_memory` / `writeMem` | ç»Ÿä¸€é£æ ¼ |
| ä¸æè¿°æ€§ | `fn process()` | `fn execute_instruction()` |

### é”™è¯¯å¤„ç†é—®é¢˜

```rust
// âŒ æ¶ˆé™¤é”™è¯¯
let result = dangerous_operation().unwrap();

// âŒ å¿½ç•¥é”™è¯¯
let _ = dangerous_operation();

// âœ… æ­£ç¡®å¤„ç†
let result = dangerous_operation()?;
// æˆ–
let result = dangerous_operation()
    .map_err(|e| Error::from(e))?;
```

### æµ‹è¯•é—®é¢˜

```rust
// âŒ åªæµ‹è¯•æ­£å¸¸è·¯å¾„
#[test]
fn test_read() {
    assert_eq!(read(0), 42);
}

// âœ… ä¹Ÿæµ‹è¯•é”™è¯¯è·¯å¾„
#[test]
fn test_read_invalid() {
    assert!(read(9999).is_err());
}
```

### æ€§èƒ½é—®é¢˜

```rust
// âŒ å¤šæ¬¡åˆ†é…
for i in 0..1000 {
    let s = format!("value: {}", i);  // æ¯æ¬¡åˆ†é…
    use(s);
}

// âœ… é¢„åˆ†é…æˆ–é‡ç”¨
let mut s = String::with_capacity(16);
for i in 0..1000 {
    s.clear();
    s.push_str("value: ");
    s.push_str(&i.to_string());
    use(&s);
}
```

## åé¦ˆæŠ€å·§

### åé¦ˆæ ¼å¼

#### 1. é—®é¢˜ï¼ˆQuestionï¼‰

**ç›®çš„**ï¼šç†è§£ä½œè€…çš„æ„å›¾

```markdown
# é—®é¢˜

æˆ‘æ³¨æ„åˆ°è¿™é‡Œä½¿ç”¨äº†`HashMap`ï¼Œè€Œä¸æ˜¯`BTreeMap`ã€‚
è¿™æ˜¯æœ‰ç‰¹å®šçš„æ€§èƒ½è€ƒè™‘å—ï¼Ÿè¿˜æ˜¯åŸºäºå…¶ä»–åŸå› ï¼Ÿ
```

#### 2. å»ºè®®ï¼ˆSuggestionï¼‰

**ç›®çš„**ï¼šæå‡ºæ”¹è¿›å»ºè®®

```markdown
# å»ºè®®

è€ƒè™‘ä½¿ç”¨`Vec::with_capacity`é¢„åˆ†é…ç©ºé—´ï¼Œ
è¿™æ ·å¯ä»¥é¿å…å¤šæ¬¡é‡æ–°åˆ†é…ï¼š

```rust
let mut items = Vec::with_capacity(expected_size);
```
```

#### 3. è¦æ±‚ï¼ˆMust Fixï¼‰

**ç›®çš„**ï¼šå¿…é¡»ä¿®å¤çš„é—®é¢˜

```markdown
# å¿…é¡»ä¿®å¤

è¿™é‡Œç¼ºå°‘å¯¹`ptr`ä¸ºç©ºçš„æ£€æŸ¥ï¼Œä¼šå¯¼è‡´ç©ºæŒ‡é’ˆè§£å¼•ç”¨ã€‚

è¯·æ·»åŠ ï¼š
```rust
if ptr.is_null() {
    return Err(Error::NullPointer);
}
```

æˆ–è€…è€ƒè™‘ä½¿ç”¨å®‰å…¨çš„`Option<&T>`ã€‚
```

#### 4. ç§°èµï¼ˆPraiseï¼‰

**ç›®çš„**ï¼šè®¤å¯å¥½çš„å®è·µ

```markdown
# å¾ˆå¥½ï¼

è¿™ä¸ªé”™è¯¯å¤„ç†éå¸¸å®Œå–„ï¼Œè€ƒè™‘åˆ°äº†æ‰€æœ‰è¾¹ç•Œæƒ…å†µã€‚
ğŸ‘ ç‰¹åˆ«æ˜¯ä½¿ç”¨`checked_add`é¿å…æº¢å‡ºçš„åšæ³•ã€‚
```

### åé¦ˆè¯­æ°”

#### å¥½çš„åé¦ˆ

âœ… "è€ƒè™‘ä½¿ç”¨..."
âœ… "æˆ‘å»ºè®®..."
âœ… "ä¸ºä»€ä¹ˆä¸å°è¯•..."
âœ… "æ–‡æ¡£ä¸­æåˆ°..."

#### é¿å…çš„åé¦ˆ

âŒ "ä½ å¿…é¡»..."
âŒ "è¿™æ˜¯é”™çš„"
âŒ "æˆ‘ä¸å–œæ¬¢..."
âŒ "é‡å†™è¿™ä¸ª"

### ä¼˜å…ˆçº§æ ‡è®°

ä½¿ç”¨æ ‡ç­¾è¡¨ç¤ºä¼˜å…ˆçº§ï¼š

- **[å¿…é¡»]**ï¼šé˜»å¡åˆå¹¶çš„é—®é¢˜
- **[é‡è¦]**ï¼šå¼ºçƒˆå»ºè®®ä¿®å¤
- **[å»ºè®®]**ï¼šå¯é€‰æ”¹è¿›
- **[è®¨è®º]**ï¼šéœ€è¦è®¨è®ºçš„è®¾è®¡é—®é¢˜

### ç¤ºä¾‹åé¦ˆ

```markdown
## ä»£ç å®¡æŸ¥åé¦ˆ

### [å¿…é¡»] å®‰å…¨é—®é¢˜

ç¬¬42è¡Œä½¿ç”¨äº†`unsafe`ä½†æ²¡æœ‰å……åˆ†è¯´æ˜å®‰å…¨æ€§ã€‚è¯·æ·»åŠ è¯¦ç»†æ³¨é‡Šè¯´æ˜ï¼š
1. ä¸ºä»€ä¹ˆéœ€è¦unsafe
2. æ»¡è¶³äº†å“ªäº›å®‰å…¨æ¡ä»¶

### [é‡è¦] æ€§èƒ½

ç¬¬80-85è¡Œåœ¨å¾ªç¯ä¸­é‡å¤åˆ›å»º`HashMap`ã€‚è€ƒè™‘ç§»åˆ°å¾ªç¯å¤–ï¼š

```rust
// å½“å‰
for item in items {
    let map = HashMap::new();  // æ¯æ¬¡åˆ›å»º
    // ...
}

// å»ºè®®
let mut map = HashMap::new();
for item in items {
    map.clear();
    // ...
}
```

### [å»ºè®®] å¯è¯»æ€§

`calculate()`å‡½æ•°å¾ˆé•¿ï¼ˆ200è¡Œï¼‰ã€‚è€ƒè™‘æ‹†åˆ†ä¸ºï¼š
- `calculate_initial_state()`
- `process_transitions()`
- `finalize_result()`

### [è®¨è®º] è®¾è®¡

æˆ‘æ³¨æ„åˆ°ä½¿ç”¨äº†`Trait Object`è€Œä¸æ˜¯æ³›å‹ã€‚è¿™æ˜¯å‡ºäºä»€ä¹ˆè€ƒè™‘ï¼Ÿ
å¯èƒ½çš„å½±å“ï¼š
- æ€§èƒ½ï¼ˆåŠ¨æ€åˆ†å‘ï¼‰
- ç±»å‹å®‰å…¨
- çµæ´»æ€§

### å¾ˆå¥½ï¼

- âœ… æµ‹è¯•è¦†ç›–ç‡å¾ˆé«˜ï¼ˆ95%ï¼‰
- âœ… æ–‡æ¡£å¾ˆè¯¦ç»†
- âœ… é”™è¯¯å¤„ç†å®Œå–„
```

## æ‰¹å‡†æ ‡å‡†

### å¿…é¡»æ»¡è¶³

- [ ] æ‰€æœ‰CIæ£€æŸ¥é€šè¿‡
- [ ] ä»£ç è´¨é‡å¯æ¥å—
- [ ] æµ‹è¯•å……åˆ†
- [ ] æ–‡æ¡£å®Œæ•´
- [ ] æ— å·²çŸ¥å®‰å…¨æ¼æ´
- [ ] æ€§èƒ½å¯æ¥å—ï¼ˆæ²¡æœ‰æ˜æ˜¾é€€åŒ–ï¼‰

### å®¡æŸ¥è€…æ•°é‡

| PRç±»å‹ | æœ€å°‘æ‰¹å‡†æ•° | å»ºè®® |
|--------|-----------|------|
| æ–‡æ¡£/å°ä¿®å¤ | 1 | 1ä½ç»´æŠ¤è€… |
| åŠŸèƒ½PR | 2 | 1-2ä½ç»´æŠ¤è€… |
| é‡å¤§å˜æ›´ | 3 | 2-3ä½ç»´æŠ¤è€… |
| RFCå®æ–½ | 3 | TSCæˆå‘˜å‚ä¸ |

### æ‰¹å‡†æµç¨‹

1. **åˆæ­¥å®¡æŸ¥**ï¼šæä¾›åé¦ˆ
2. **ä½œè€…ä¿®æ”¹**ï¼šè§£å†³é—®é¢˜
3. **éªŒè¯ä¿®æ”¹**ï¼šæ£€æŸ¥ä¿®æ”¹
4. **ç»™äºˆæ‰¹å‡†**ï¼šç‚¹å‡»"Approve"æŒ‰é’®
5. **åˆå¹¶**ï¼šé€šå¸¸ç”±ç»´æŠ¤è€…åˆå¹¶

### ä¸æ‰¹å‡†çš„æƒ…å†µ

åœ¨ä»¥ä¸‹æƒ…å†µä¸‹**ä¸æ‰¹å‡†**ï¼š

- âš ï¸ CIæ£€æŸ¥å¤±è´¥
- âš ï¸ å®‰å…¨æ¼æ´
- âš ï¸ ä¸¥é‡æ€§èƒ½é—®é¢˜
- âš ï¸ æµ‹è¯•ä¸è¶³ï¼ˆ<60%è¦†ç›–ç‡ï¼‰
- âš ï¸ æ–‡æ¡£ç¼ºå¤±
- âš ï¸ Breaking changesæœªè¯´æ˜

## æœ€ä½³å®è·µ

### ä½œä¸ºå®¡æŸ¥è€…

1. **åŠæ—¶å“åº”**ï¼šå°½é‡åœ¨48å°æ—¶å†…å“åº”
2. **åˆ†æ‰¹å®¡æŸ¥**ï¼šå¤§å‹PRå¯ä»¥åˆ†æ‰¹å®¡æŸ¥
3. **å»ºè®¾æ€§**ï¼šæä¾›è§£å†³æ–¹æ¡ˆï¼Œä¸åªæ˜¯æŒ‡å‡ºé—®é¢˜
4. **æ‰¿è®¤æ—¶é—´**ï¼šå¤æ‚PRéœ€è¦æ›´å¤šæ—¶é—´
5. **å­¦ä¹ å¿ƒæ€**ï¼šä»å¥½çš„ä»£ç ä¸­å­¦ä¹ 

### ä½œä¸ºä½œè€…

1. **å°PR**ï¼šä¿æŒPRå°è€Œä¸“æ³¨
2. **è‡ªå®¡æŸ¥**ï¼šæäº¤å‰è‡ªæˆ‘å®¡æŸ¥
3. **æ¸…æ™°æè¿°**ï¼šæä¾›å……åˆ†çš„ä¸Šä¸‹æ–‡
4. **å“åº”åŠæ—¶**ï¼šåŠæ—¶å›å¤åé¦ˆ
5. **æ¥å—å»ºè®®**ï¼šè™šå¿ƒæ¥å—å»ºè®®

### å¤„ç†åˆ†æ­§

1. **è®¨è®ºä¼˜å…ˆ**ï¼šå…ˆè®¨è®ºï¼Œç†è§£å¯¹æ–¹è§‚ç‚¹
2. **æ•°æ®é©±åŠ¨**ï¼šä½¿ç”¨æ•°æ®å’Œè¯æ®æ”¯æŒ
3. **å¯»æ±‚ç¬¬ä¸‰æ„è§**ï¼šå¦‚æœæ— æ³•è¾¾æˆä¸€è‡´ï¼Œè¯·ç¬¬ä¸‰æ–¹è¯„ä¼°
4. **å°Šé‡å†³å®š**ï¼šæœ€ç»ˆç”±ç»´æŠ¤è€…åšå†³å®š

## å·¥å…·å’Œè‡ªåŠ¨åŒ–

### GitHubå·¥å…·

- **Review suggestions**ï¼šé€è¡Œè¯„è®º
- **Draft PR**ï¼šè‰ç¨¿PRï¼Œéæ­£å¼å®¡æŸ¥
- **Assign reviewers**ï¼šæŒ‡æ´¾å®¡æŸ¥è€…

### CIé›†æˆ

```yaml
# .github/workflows/review.yml
name: Review Checklist

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  review-checklist:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Check PR size
        run: |
          files=$(git diff --name-only HEAD^ | wc -l)
          if [ $files -gt 20 ]; then
            echo "::warning::PR touches $files files, consider splitting"
          fi
```

### è‡ªåŠ¨åŒ–å·¥å…·

```bash
# ä»£ç è¦†ç›–ç‡
cargo tarpaulin --out Html

# å¤æ‚åº¦æ£€æŸ¥
cargo install cargo-geiger
cargo geiger

# ä¾èµ–å®¡è®¡
cargo audit
```

## èµ„æº

### å†…éƒ¨èµ„æº

- [ç¼–ç è§„èŒƒ](CONTRIBUTING.md)
- [APIæŒ‡å—](docs/API_INDEX.md)
- [æ¶æ„æ–‡æ¡£](docs/architecture/)

### å¤–éƒ¨èµ„æº

- [Rust API Guidelines](https://rust-lang.github.io/api-guidelines/)
- [Effective Rust](https://doc.rust-lang.org/book/)
- [Google Code Review Guide](https://google.github.io/eng-practices/review/)

---

**æ–‡æ¡£ç‰ˆæœ¬**ï¼š1.0.0
**æœ€åæ›´æ–°**ï¼š2024å¹´12æœˆ31æ—¥

æ„Ÿè°¢æ‚¨å‚ä¸ä»£ç å®¡æŸ¥ï¼Œè¿™ä½¿VMé¡¹ç›®å˜å¾—æ›´å¥½ï¼
