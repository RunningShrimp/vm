# 使用 AOT 提升系统级虚拟机性能的架构设计

## 背景与目标
- 背景：当前系统采用 JIT/DBT（动态二进制翻译）运行客体 OS 与应用，存在冷启动翻译开销与运行期抖动。
- 目标：引入 AOT（静态/预编译二进制翻译）与混合 AOT+JIT 架构，降低冷启动和稳定热路径的翻译成本，提升整体吞吐与时延稳定性。
- 场景：系统级虚拟化/全系统仿真（非字节码虚拟机）；需覆盖特权指令、MMU、异常/中断、设备 I/O 等语义。

## 范围与非目标
- 范围：AOT 构建流水线、镜像格式与加载器、运行时语义接口、缓存与失效、与现有运行时的集成。
- 非目标：替代设备仿真/硬件虚拟化；不改变现有设备模型与调度策略。

## 关键假设与术语
- 客体（Guest）：需要在宿主 ISA 上执行的 OS 与应用二进制。
- 宿主（Host）：运行本虚拟机的硬件与 OS。
- AOT 镜像：针对特定客体映像版本预编译的宿主指令代码及元数据。
- 运行时 API：封装 CPU 状态、MMU、异常/中断与设备访问的宿主接口。

## 总体架构
- 离线构建：依据采样/CFG 导出，将客体指令抬升至中间表示（LLVM IR 等），静态优化并编译为宿主代码，打包为 AOT 镜像。
- 启动加载：匹配并映射可用的 AOT 镜像；未覆盖部分由 JIT 翻译并可异步加入缓存。
- 运行期协同：AOT 命中路径直接执行；自修改/模块变更触发失效回退到 JIT；异常/中断与设备语义通过运行时 API 统一托管。

## 组件设计
### 1) AOT 构建器（离线）
- 热区采集：在现有 JIT 中启用基本块计数与 CFG 导出，生成候选翻译单元（函数/BB）。
- 指令抬升：使用指令语义库（如 Remill）将客体指令抬升到 LLVM IR；用控制流恢复工具（如 McSema）拼接函数级 IR。
- 编译与优化：运行 LLVM 优化（含 PGO 可选），生成宿主目标代码或共享库。
- 镜像打包：记录 build-id、段映射、符号、跳板表、间接跳转查找表、版本与校验元数据。

### 2) AOT 镜像格式
- 元数据：`guest_build_id`、`guest_image_ranges`、`host_text_ranges`、`trampoline_table`、`indirect_lookup`、`w^x_flags`、`abi_version`。
- 映射：保持客体地址到宿主地址的双向映射，用于异常回溯与调试。
- 安全：镜像签名与校验；代码页 W^X；只读段保护与运行时页级失效。

### 3) AOT 加载器（运行时）
- 匹配：按 `build-id` 与模块版本匹配镜像；不匹配则禁用 AOT。
- 映射：将宿主代码段映射至代码缓存；安装跳板与查表以支持间接跳转与跨单元调用。
- 绑定：绑定运行时 API（CPU 状态、MMU、异常/中断、设备 I/O）。

### 4) 执行运行时
- CPU 状态：寄存器、标志位、FPU/SIMD 状态的结构化表示与读写接口。
- MMU/访存：统一通过运行时接口执行访存与页表操作，保证语义一致（含访问异常）。
- 异常与中断：AOT 代码遇到特权/异常路径时调用运行时，进行派发与栈/上下文切换；简单特权指令可用内联序列加速，复杂操作调用运行时。
- 设备 I/O：通过设备仿真层提供的 API 完成端口/内存映射 I/O。

### 5) 缓存与失效
- 写时失效：对代码页采用写保护；写入触发陷入，标记相关 AOT 条目失效并回退至 JIT。
- 模块事件：模块加载/卸载、内核 alternatives/paravirt 路径触发镜像失效或重绑定。
- 快照持久化：保存/恢复时同步缓存命中统计与镜像引用，提升恢复后命中率。

## 与现有实现的集成点
- 启动加载：在 `vm-boot/src/runtime.rs:205` 的 `start()` 中引入 AOT 加载流程（镜像匹配→映射→绑定）。
- 事件轮询：在 `vm-boot/src/runtime.rs:145` 的 `poll_events()` 中对 `SaveSnapshot`/`LoadSnapshot` 分支（`vm-boot/src/runtime.rs:169-171`）同步缓存与镜像关联信息。
- 状态更新：在 `vm-boot/src/runtime.rs:180` 的 `update_state()` 中保持运行/暂停/关闭状态与 AOT 失效策略的一致性（例如关闭前刷新统计）。

## 执行流程（文字时序）
1. 冷启动：读取客体镜像信息→匹配 AOT 镜像→映射宿主代码→安装跳板与查表→进入运行循环；未命中区域由 JIT 翻译。
2. 运行期：
   - 直接控制流：AOT 内部重定位直接跳转；跨单元调用通过跳板或直接链接。
   - 间接控制流：查表或哈希映射解析目标；未解析目标回退 JIT 并可异步回填。
   - 特权/异常：内联序列处理简单指令；复杂上下文切换调用运行时。
3. 快照：在保存时持久化 AOT 命中统计与镜像引用；恢复时优先加载对应镜像以减少抖动。

## 安全与隔离
- W^X：代码页写异或执行；写入触发失效与审计。
- 隔离：运行时 API 不暴露宿主敏感资源；AOT 执行受控于 VM 沙箱与设备仿真层。
- 校验：镜像签名与版本校验，防止拼接错误或篡改。

## 兼容性与版本控制
- 绑定策略：以 `guest_build_id + 模块版本` 绑定 AOT 镜像；不匹配时禁用。
- 重建流程：新版本镜像发布→离线流水线重建→灰度加载→命中率与性能评估。

## 性能指标与度量
- 指标：冷启动时延、翻译时间占比、AOT 命中率、跨页/间接跳转开销、整体吞吐与端到端时延。
- 方法：对相同工作负载比较“JIT-only vs Hybrid AOT+JIT”；引入 perf/火焰图与 PMU 计数。

## 运维与可观测性
- 日志：镜像加载/卸载、失效事件、异常回退、JIT 回退原因。
- 指标：命中率、失效次数、跳板命中、查表开销、AOT 与 JIT 时间比。
- 故障定位：提供地址映射查询与异常回溯工具。

## 风险与应对
- 代码发现不全：采用混合模式与运行时探针，未覆盖路径回退 JIT。
- 自修改/补丁：写时失效与快速回退；对白名单模块（alternatives/paravirt）做专门策略。
- 维护成本：镜像强绑定版本，建立自动重建与灰度发布管线。

## 演进路线
- PoC：选定单一用户态二进制/常用库，完成 AOT 构建与加载，验证冷启动收益。
- 中期：扩展到稳定内核模块；完善写时失效、异常/中断托管、快照持久化。
- 长期：更广覆盖与 IR 优化（PGO）、间接跳转预测与跳板加速、设备仿真协同优化。

## 参考资料
- Binary translation 概述（静态/动态）：https://en.wikipedia.org/wiki/Binary_translation
- Rosetta 2（AOT 文件 + 运行期 JIT）：https://ffri.github.io/ProjectChampollion/part1/
- Remill（指令语义抬升到 LLVM IR）：https://github.com/lifting-bits/remill
- McSema（控制流恢复与函数级 IR 拼接）：https://github.com/lifting-bits/mcsema
- 系统级 DBT 优化评估（ARMv7-A）：https://dl.acm.org/doi/10.1016/j.sysarc.2016.03.001
