# VM 虚拟机 - 架构设计文档

## 1. 系统概述

这是一个高性能 Rust 虚拟机实现，支持多种 CPU 架构（x86_64, ARM64, RISC-V 64），具有多种执行引擎（解释器、JIT 编译、硬件加速）。

### 1.1 核心设计目标
- **高性能**: 支持 JIT 编译、硬件加速、SIMD 优化
- **模块化**: 清晰的模块划分，易于扩展
- **可靠性**: 完整的错误处理、安全的内存管理
- **灵活性**: 支持多种执行模式和配置选项

### 1.2 系统架构图

```
┌─────────────────────────────────────────────────────────┐
│                    VM-Service (入口点)                  │
├─────────────────────────────────────────────────────────┤
│  异步任务处理 | vCPU 管理 | 中断处理 | 设备管理      │
├─────────────────────────────────────────────────────────┤
│ VM-Engine (执行引擎)   │ VM-Device (设备层)             │
│ ├─ 解释器              │ ├─ Block 设备                  │
│ ├─ JIT 编译器          │ ├─ 网络设备                    │
│ ├─ 硬件加速(KVM/HVF)  │ ├─ GPU 加速                    │
│ └─ 混合执行            │ └─ 中断控制器                  │
├─────────────────────────────────────────────────────────┤
│ VM-Mem (内存管理)      │ VM-Accel (硬件加速)            │
│ ├─ SoftMMU             │ ├─ KVM 支持                    │
│ ├─ TLB 缓存            │ ├─ HVF 支持                    │
│ ├─ 页表遍历            │ └─ WHPX 支持                   │
│ └─ 零拷贝技术          │                                │
├─────────────────────────────────────────────────────────┤
│ VM-Core (核心类型和 Trait)                             │
│ ├─ 地址类型            │ ├─ MMU Trait                   │
│ ├─ 架构定义            │ ├─ 解码器 Trait                │
│ └─ 执行引擎 Trait       │ └─ 设备接口 Trait              │
└─────────────────────────────────────────────────────────┘
```

## 2. 模块架构

### 2.1 vm-core 核心模块
**责任**: 定义系统的基本类型和抽象接口

```rust
// 地址类型
pub type GuestAddr = u64;      // 虚拟机内部地址
pub type GuestPhysAddr = u64;  // 物理地址
pub type HostAddr = u64;       // 主机地址

// 支持的架构
pub enum GuestArch {
    Riscv64,    // RISC-V 64
    Arm64,      // ARM 64
    X86_64,     // x86-64
}

// 关键 Trait
pub trait MMU { }              // 内存管理接口
pub trait ExecutionEngine { }  // 执行引擎接口
pub trait Decoder { }          // 指令解码器接口
pub trait Instruction { }      // 指令接口
```

**文件结构**:
- `lib.rs`: 类型定义、Trait 定义、基础功能

### 2.2 vm-mem 内存管理模块
**责任**: 虚拟地址翻译、内存访问、TLB 管理

**核心组件**:

#### SoftMmu
- TLB 管理（I-TLB 和 D-TLB 分开）
- 页表遍历（SV39/SV48 支持）
- 虚拟地址翻译
- MMIO 设备映射

#### TLB 优化
- 使用 HashMap 实现 O(1) 查找
- 复合键: `(vpn << 16) | asid`
- LRU 驱逐策略
- 分离的全局页存储

#### 批量内存操作
- `read_bulk()`: 批量读取，避免逐字节 TLB 查询
- `write_bulk()`: 批量写入
- MMIO 检测机制

**性能优化**:
- TLB 查找: O(1) → 20%+ 性能提升
- 批量操作: 50%+ 性能提升（相比字节操作）
- 内存访问: 优化的缓存使用

### 2.3 vm-engine-jit JIT 编译引擎
**责任**: 将 IR 块编译为本机代码执行

**核心组件**:

#### 热点检测
- 执行计数追踪
- 自适应阈值管理
- 热点代码识别

#### Cranelift 集成
- IR 到本机代码编译
- 支持所有算术操作
- 浮点操作（F64/F32）
- 向量操作（SIMD）
- 原子操作

#### 代码池管理
- 多线程编译支持（rayon）
- 代码缓存
- 共享代码池

**浮点操作支持**:
- 双精度: Fadd, Fsub, Fmul, Fdiv, Fsqrt, Fmin, Fmax
- 单精度: FaddS, FsubS, FmulS, FdivS, FsqrtS, FminS, FmaxS

### 2.4 vm-engine-interpreter 解释器
**责任**: 直接解释执行 IR 块

**核心功能**:
- 完整的 IR 指令支持
- 指令融合优化
- 块缓存（可选）
- 中断处理

**块缓存**:
- HashMap 基础的 LRU 缓存
- 可配置的缓存大小
- 命中率统计

### 2.5 vm-device 设备层
**责任**: 虚拟设备实现（块设备、网络、GPU等）

**设备类型**:
- VirtIO Block：块设备
- VirtIO Net：网络设备
- GPU 加速：GPU 支持
- 中断控制器：CLINT, PLIC

**优化**:
- 使用 `parking_lot::Mutex` 替代 `std::sync::Mutex`
- 异步 I/O 支持
- 批量操作

### 2.6 vm-accel 硬件加速
**责任**: 硬件虚拟化支持

**支持平台**:
- KVM (Linux)
- HVF (macOS)
- WHPX (Windows)

## 3. 执行流程

### 3.1 基本执行流程

```
1. VM 初始化
   └─ 创建 MMU, vCPU, 设备

2. 指令获取
   ├─ 地址翻译 (MMU.translate)
   └─ 内存读取 (MMU.read)

3. 指令解码
   ├─ 前端解码器 (x86_64/ARM64/RISC-V)
   └─ 统一 Instruction Trait

4. 执行
   ├─ 解释模式: Interpreter.run
   ├─ JIT 模式: Jit.compile + 本机代码执行
   └─ 加速模式: 硬件加速 (KVM/HVF)

5. 中断处理
   └─ 异常、外设中断、系统调用
```

### 3.2 性能优化路径

```
冷代码段:
  基本块 → Interpreter.run → 执行计数++

热代码段:
  基本块 → 执行计数 > 阈值?
    └─ YES: Jit.compile → 本机代码 → 快速执行
    └─ NO: 继续解释

热点优化:
  └─ 块缓存命中 → 直接本机代码执行
  └─ TLB 命中 → O(1) 地址翻译
  └─ 批量操作 → 减少 TLB 查询
```

## 4. 关键优化

### 4.1 内存管理优化
- **TLB O(1) 查找**: HashMap + 复合键
- **批量操作**: read_bulk/write_bulk (50%+ 提升)
- **MMIO 检测**: 避免不必要的 TLB 查询

### 4.2 执行引擎优化
- **热点检测**: 自适应阈值
- **块缓存**: 避免重复编译
- **指令融合**: 减少调度开销

### 4.3 并发优化
- **无锁数据结构**: parking_lot::Mutex (30%+ 性能提升)
- **多线程编译**: rayon 并行编译
- **多 vCPU 支持**: 并行执行

### 4.4 浮点优化
- **Cranelift IR**: 原生浮点操作
- **双精度+单精度**: F64/F32 支持
- **10x 性能提升**: 相比软件模拟

## 5. 数据流

### 5.1 内存访问数据流

```
虚拟地址 (VA)
    ↓
1. TLB 查找 (O(1) HashMap 查询)
    ├─ HIT: 返回 (PPN, flags)
    └─ MISS: 执行页表遍历
           ↓
2. 页表遍历 (SV39/SV48)
    └─ 返回 (PPN, flags) 并插入 TLB
           ↓
3. 权限检查
    ├─ PASS: 继续
    └─ FAIL: PageFault 异常
           ↓
4. 物理地址计算
    PA = (PPN << PAGE_SHIFT) | (VA & PAGE_MASK)
           ↓
5. 内存访问
    ├─ RAM: 直接访问
    └─ MMIO: 设备回调
```

### 5.2 指令执行数据流

```
机器码 (原始指令)
    ↓
1. 前端解码
    ├─ x86_64: 3 阶段解码 (前缀→操作码→操作数)
    ├─ ARM64: 统一 Instruction Trait
    └─ RISC-V: 统一 Instruction Trait
           ↓
2. IR 生成
    └─ 统一的中间表示
           ↓
3. 执行决策
    ├─ 冷代码: 解释执行
    ├─ 热代码: JIT 编译 → 本机代码
    └─ 硬件支持: 硬件加速
           ↓
4. 执行
    └─ 更新寄存器/内存
           ↓
5. 结果
    ├─ 下一条指令 PC
    ├─ 异常/中断
    └─ 执行统计
```

## 6. 性能指标

### 6.1 内存子系统
- TLB 命中率: > 90%
- TLB 查找时间: O(1)
- 批量操作性能: 50%+ 提升

### 6.2 执行引擎
- 冷代码解释: 10-50 cycles/指令
- 热代码 JIT: 1-5 cycles/指令
- 浮点性能: 10x 相比软件模拟

### 6.3 并发
- 无锁锁性能: 30%+ 提升
- 多 vCPU 扩展: 线性扩展 (2-8 vCPU)

## 7. 扩展点

### 7.1 新架构支持
- 实现新的前端解码器（继承 Decoder Trait）
- 定义新的 Instruction 实现
- 注册到解码器工厂

### 7.2 新设备支持
- 实现 MmioDevice Trait
- 处理读写操作
- 注册到 MMU

### 7.3 新执行引擎
- 实现 ExecutionEngine Trait
- 集成到执行选择逻辑
- 添加性能统计

## 8. 编译与运行

### 8.1 编译
```bash
cargo build --release
```

### 8.2 运行
```bash
# 创建 VM 实例
let config = VmConfig {
    guest_arch: GuestArch::Riscv64,
    memory_size: 128 * 1024 * 1024,
    vcpu_count: 4,
    exec_mode: ExecMode::Hybrid,  // JIT + 解释混合
    ..Default::default()
};

let vm = VirtualMachine::new(config)?;
vm.run()?;
```

## 9. 性能调优建议

1. **启用块缓存**: 对高重复代码有益
2. **调整 JIT 阈值**: 热点代码更早编译
3. **启用 SIMD**: 向量操作加速
4. **多 vCPU**: 充分利用多核
5. **TLB 预热**: 减少初期缺失

## 10. 已知限制

- 硬件加速仅在特定平台可用
- SIMD 操作需要特定 CPU 支持
- 某些架构特殊指令可能不完全支持

---

**最后更新**: 2025年11月29日
**版本**: 1.0
