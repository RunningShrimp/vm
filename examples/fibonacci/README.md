# Fibonacci计算示例

这个示例展示如何在VM中执行更复杂的程序,包括循环、内存访问和数组操作。

## 功能特性

1. **完整的RISC-V程序** - 实现Fibonacci数列计算
2. **内存操作** - 使用数组存储计算结果
3. **控制流** - 循环和条件跳转
4. **结果验证** - 自动验证计算正确性

## 运行示例

```bash
cargo run --example fibonacci
```

## 预期输出

```
=== Fibonacci计算示例 ===

计算前 10 个Fibonacci数

步骤 1: 创建VM配置
✅ 配置创建成功

步骤 2: 设置内存
✅ 内存区域配置完成
   代码段: 0x1000 - 0x2000
   数据段: 0x10000 - 0x11000

步骤 3: 生成Fibonacci程序
✅ 程序已加载 (XXX 字节)

步骤 4: 初始化数据
   N = 10 (存储在 0x10000)
   fib[0] = 0
   fib[1] = 1

步骤 5: 创建执行引擎
✅ 执行引擎就绪

步骤 6: 执行Fibonacci程序
--- 开始执行 ---

✅ 程序执行完成
执行指令数: XXX

步骤 7: 读取结果
Fibonacci数列:
fib[0] = 0        fib[1] = 1        fib[2] = 1        fib[3] = 2        fib[4] = 3
fib[5] = 5        fib[6] = 8        fib[7] = 13       fib[8] = 21       fib[9] = 34

步骤 8: 验证结果
✅ 所有结果验证通过!

步骤 9: 性能统计
  总指令数: XXX
  执行时间: XXX
  平均每指令: XXX
```

## 程序结构

### RISC-V汇编代码

程序使用以下RISC-V指令:

```assembly
# 初始化
lui  x3, 0x10        # 加载数据段基址 (0x10000)
ld   x2, 0(x3)       # 读取 N
li   x1, 2           # 初始化循环计数器 i = 2
ld   x4, 8(x3)       # 加载 fib[0] = 0
ld   x5, 16(x3)      # 加载 fib[1] = 1

# 循环体
loop:
  add   x6, x4, x5    # x6 = fib[i-2] + fib[i-1]
  slli  x7, x1, 3     # x7 = i * 8 (计算字节偏移)
  add   x7, x3, x7    # x7 = &fib[i]
  sd    x6, 8(x7)     # fib[i] = x6
  addi  x4, x5, 0     # x4 = x5
  mv    x5, x6        # x5 = x6
  addi  x1, x1, 1     # i++
  blt   x1, x2, loop  # if i < N, 继续循环

ret                   # 返回
```

### 内存布局

```
地址          内容
--------      ------
0x10000       N (数组长度)
0x10008       fib[0] = 0
0x10010       fib[1] = 1
0x10018       fib[2] = 1
0x10020       fib[3] = 2
...
```

### 寄存器使用

| 寄存器 | 用途 |
|--------|------|
| x1     | 循环计数器 i |
| x2     | 数组长度 N |
| x3     | 数组基址 |
| x4     | fib[i-2] |
| x5     | fib[i-1] |
| x6     | fib[i] (计算结果) |
| x7     | 临时地址 |

## 学习要点

### 1. 内存访问

RISC-V使用load/store架构:
- `ld` (load doubleword): 从内存读取8字节
- `sd` (store doubleword): 向内存写入8字节

### 2. 数组索引

数组元素访问需要计算字节偏移:
```assembly
slli x7, x1, 3     # index * 8 (因为每个元素8字节)
add  x7, x3, x7    # base_address + offset
```

### 3. 循环实现

RISC-V使用条件跳转实现循环:
```assembly
addi x1, x1, 1     # 增加计数器
blt  x1, x2, loop  # 如果 i < N, 跳转到loop
```

### 4. 数据移动

使用`mv`伪指令(实际是`addi rd, rs, 0`):
```assembly
mv x5, x6          # x5 = x6
```

## 扩展练习

尝试修改程序:

1. **计算更大的N** - 修改代码中的`n`值
2. **优化算法** - 使用更少的寄存器
3. **添加边界检查** - 防止数组越界
4. **实现其他数列** - 如阶乘、三角形数等

## 性能优化

### 当前实现

- 每次迭代: 10条指令
- 总指令数: ~10 * N

### 可能的优化

1. **循环展开** - 每次迭代计算多个值
2. **寄存器优化** - 减少内存访问
3. **JIT编译** - 启用JIT可提升10-100倍性能

## 故障排除

### 数组越界

如果遇到内存访问错误,检查:
- 数组基址是否正确
- 偏移计算是否正确
- N值是否在合理范围内

### 结果不正确

如果计算结果错误,检查:
- 初始值fib[0]和fib[1]是否正确
- 循环次数是否正确
- 寄存器使用是否有冲突

## 相关文档

- [RISC-V指令集参考](../../docs/tutorials/RISCV_PROGRAMMING.md)
- [Hello World示例](../hello_world/)
- [JIT执行示例](../jit_execution/)
