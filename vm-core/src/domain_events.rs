//! 领域事件定义//!//! 定义虚拟机领域的核心事件，遵循DDD事件驱动架构原则。//! 所有领域事件都是不可变的，表示已经发生的事实。use crate::VmLifecycleState;#[cfg(feature = "std")]#[allow(unused_imports)]use crate::{GuestAddr, VmError};use serde::{Deserialize, Serialize};use std::time::SystemTime;/// 领域事件基trait////// 所有领域事件都应该实现这个trait，提供事件的基本元数据。pub trait DomainEvent: Send + Sync {    /// 事件类型名称    fn event_type(&self) -> &'static str;    /// 事件发生时间    fn occurred_at(&self) -> SystemTime;    /// 事件版本（用于事件溯源和版本兼容性）    fn version(&self) -> u64 {        1    }    /// 是否支持版本升级    fn supports_version_upgrade(&self) -> bool {        false    }}/// 事件版本信息#[derive(Debug, Clone, Serialize, Deserialize)]pub struct EventVersion {    /// 事件类型    pub event_type: String,    /// 版本号    pub version: u64,    /// 创建时间    pub created_at: SystemTime,    /// 是否向后兼容    pub backward_compatible: bool,    /// 迁移说明    pub migration_notes: Option<String>,}/// 事件版本迁移器////// 处理不同版本事件之间的升级和兼容性pub struct EventVersionMigrator;impl EventVersionMigrator {    /// 迁移事件到最新版本    pub fn migrate_to_latest(event: DomainEventEnum) -> Result<DomainEventEnum, String> {        let current_version = event.version();        let latest_version = Self::get_latest_version(event.event_type());        if current_version >= latest_version {            return Ok(event);        }        // 执行版本升级        let mut upgraded_event = event;        for version in (current_version + 1)..=latest_version {            upgraded_event = Self::upgrade_event(upgraded_event, version)?;        }        Ok(upgraded_event)    }    /// 升级单个事件版本    fn upgrade_event(        event: DomainEventEnum,        target_version: u64,    ) -> Result<DomainEventEnum, String> {        match event {            DomainEventEnum::VmLifecycle(ref lifecycle_event) => {                Self::upgrade_vm_lifecycle_event(lifecycle_event.clone(), target_version)            }            DomainEventEnum::Memory(ref memory_event) => {                Self::upgrade_memory_event(memory_event.clone(), target_version)            }            DomainEventEnum::Execution(ref execution_event) => {                Self::upgrade_execution_event(execution_event.clone(), target_version)            }            DomainEventEnum::Device(ref device_event) => {                Self::upgrade_device_event(device_event.clone(), target_version)            }            DomainEventEnum::Snapshot(_) => {                // Snapshot events currently don't support versioning                Ok(event)            }        }    }    /// 升级VM生命周期事件    fn upgrade_vm_lifecycle_event(        event: VmLifecycleEvent,        target_version: u64,    ) -> Result<DomainEventEnum, String> {        match target_version {            2 => {                // v2: 添加了额外的元数据字段                let upgraded_event = match event {                    VmLifecycleEvent::VmCreated {                        vm_id,                        config,                        occurred_at,                    } => {                        VmLifecycleEvent::VmCreatedV2 {                            vm_id,                            config,                            occurred_at,                            created_by: "system".to_string(), // 默认创建者                            tags: vec![],                     // 默认空标签                        }                    }                    VmLifecycleEvent::VmStarted { vm_id, occurred_at } => {                        VmLifecycleEvent::VmStartedV2 {                            vm_id,                            occurred_at,                            startup_time_ms: 0, // 默认启动时间                        }                    }                    VmLifecycleEvent::VmStopped {                        vm_id,                        reason,                        occurred_at,                    } => {                        VmLifecycleEvent::VmStoppedV2 {                            vm_id,                            reason,                            occurred_at,                            exit_code: 0, // 默认退出码                        }                    }                    // 其他事件保持不变                    other => other,                };                Ok(DomainEventEnum::VmLifecycle(upgraded_event))            }            _ => Ok(DomainEventEnum::VmLifecycle(event)),        }    }    /// 升级内存事件    fn upgrade_memory_event(        event: MemoryEvent,        target_version: u64,    ) -> Result<DomainEventEnum, String> {        match target_version {            2 => {                // v2: 添加了内存类型字段                let upgraded_event = match event {                    MemoryEvent::MemoryAllocated {                        vm_id,                        addr,                        size,                        occurred_at,                    } => {                        MemoryEvent::MemoryAllocatedV2 {                            vm_id,                            addr,                            size,                            occurred_at,                            memory_type: "heap".to_string(), // 默认内存类型                        }                    }                    // 其他事件保持不变                    other => other,                };                Ok(DomainEventEnum::Memory(upgraded_event))            }            _ => Ok(DomainEventEnum::Memory(event)),        }    }    /// 升级执行事件    fn upgrade_execution_event(        event: ExecutionEvent,        _target_version: u64,    ) -> Result<DomainEventEnum, String> {        // 执行事件目前只有一个版本        Ok(DomainEventEnum::Execution(event))    }    /// 升级设备事件    fn upgrade_device_event(        event: DeviceEvent,        _target_version: u64,    ) -> Result<DomainEventEnum, String> {        // 设备事件目前只有一个版本        Ok(DomainEventEnum::Device(event))    }    /// 获取事件类型的最新版本    pub fn get_latest_version(event_type: &str) -> u64 {        match event_type {            "vm.created" | "vm.started" | "vm.stopped" => 2,            "memory.allocated" => 2,            _ => 1,        }    }    /// 检查版本是否兼容    pub fn is_version_compatible(event_type: &str, version: u64) -> bool {        let latest = Self::get_latest_version(event_type);        version <= latest    }    /// 创建版本迁移工具    pub fn create_migration_tool() -> EventMigrationTool {        EventMigrationTool::new()    }}/// 事件迁移工具////// 提供命令行工具和API用于事件版本迁移pub struct EventMigrationTool;impl Default for EventMigrationTool {    fn default() -> Self {        Self::new()    }}impl EventMigrationTool {    /// 创建新的迁移工具    pub fn new() -> Self {        Self    }    /// 迁移单个事件    pub fn migrate_event(&self, event: DomainEventEnum) -> Result<DomainEventEnum, String> {        EventVersionMigrator::migrate_to_latest(event)    }    /// 迁移事件列表    pub fn migrate_events(        &self,        events: Vec<DomainEventEnum>,    ) -> Result<Vec<DomainEventEnum>, String> {        events            .into_iter()            .map(|event| self.migrate_event(event))            .collect()    }    /// 验证事件版本兼容性    pub fn validate_event_versions(&self, events: &[DomainEventEnum]) -> Vec<EventVersionIssue> {        let mut issues = Vec::new();        for event in events {            let event_type = event.event_type();            let version = event.version();            let latest_version = EventVersionMigrator::get_latest_version(event_type);            if version < latest_version {                issues.push(EventVersionIssue {                    event_type: event_type.to_string(),                    current_version: version,                    latest_version,                    issue_type: VersionIssueType::Outdated,                    description: format!(                        "Event is outdated (v{} vs latest v{})",                        version, latest_version                    ),                });            } else if version > latest_version {                issues.push(EventVersionIssue {                    event_type: event_type.to_string(),                    current_version: version,                    latest_version,                    issue_type: VersionIssueType::TooNew,                    description: format!(                        "Event version is newer than expected (v{} vs latest v{})",                        version, latest_version                    ),                });            }        }        issues    }    /// 生成版本升级报告    pub fn generate_upgrade_report(&self, events: &[DomainEventEnum]) -> EventUpgradeReport {        let issues = self.validate_event_versions(events);        let total_events = events.len();        let outdated_events = issues            .iter()            .filter(|i| i.issue_type == VersionIssueType::Outdated)            .count();        let upgradeable_events = issues            .iter()            .filter(|i| i.issue_type == VersionIssueType::Outdated)            .count();        EventUpgradeReport {            total_events,            outdated_events,            upgradeable_events,            incompatible_events: issues                .iter()                .filter(|i| i.issue_type == VersionIssueType::TooNew)                .count(),            issues,        }    }}/// 版本问题类型#[derive(Debug, Clone, PartialEq)]pub enum VersionIssueType {    /// 版本过旧    Outdated,    /// 版本过新（不兼容）    TooNew,}/// 事件版本问题#[derive(Debug, Clone)]pub struct EventVersionIssue {    /// 事件类型    pub event_type: String,    /// 当前版本    pub current_version: u64,    /// 最新版本    pub latest_version: u64,    /// 问题类型    pub issue_type: VersionIssueType,    /// 问题描述    pub description: String,}/// 事件升级报告#[derive(Debug, Clone)]pub struct EventUpgradeReport {    /// 总事件数    pub total_events: usize,    /// 过时事件数    pub outdated_events: usize,    /// 可升级事件数    pub upgradeable_events: usize,    /// 不兼容事件数    pub incompatible_events: usize,    /// 具体问题列表    pub issues: Vec<EventVersionIssue>,}/// 虚拟机生命周期事件#[derive(Debug, Clone, Serialize, Deserialize)]pub enum VmLifecycleEvent {    /// 虚拟机已创建 (v1)    VmCreated {        vm_id: String,        config: VmConfigSnapshot,        occurred_at: SystemTime,    },    /// 虚拟机已创建 (v2 - 带创建者和标签)    VmCreatedV2 {        vm_id: String,        config: VmConfigSnapshot,        occurred_at: SystemTime,        created_by: String,        tags: Vec<String>,    },    /// 虚拟机已启动 (v1)    VmStarted {        vm_id: String,        occurred_at: SystemTime,    },    /// 虚拟机已启动 (v2 - 带启动时间)    VmStartedV2 {        vm_id: String,        occurred_at: SystemTime,        startup_time_ms: u64,    },    /// 虚拟机已暂停    VmPaused {        vm_id: String,        occurred_at: SystemTime,    },    /// 虚拟机已恢复    VmResumed {        vm_id: String,        occurred_at: SystemTime,    },    /// 虚拟机已停止 (v1)    VmStopped {        vm_id: String,        reason: String,        occurred_at: SystemTime,    },    /// 虚拟机已停止 (v2 - 带退出码)    VmStoppedV2 {        vm_id: String,        reason: String,        occurred_at: SystemTime,        exit_code: i32,    },    /// 虚拟机状态已变更    VmStateChanged {        vm_id: String,        from: VmLifecycleState,        to: VmLifecycleState,        occurred_at: SystemTime,    },}impl DomainEvent for VmLifecycleEvent {    fn event_type(&self) -> &'static str {        match self {            VmLifecycleEvent::VmCreated { .. } | VmLifecycleEvent::VmCreatedV2 { .. } => {                "vm.created"            }            VmLifecycleEvent::VmStarted { .. } | VmLifecycleEvent::VmStartedV2 { .. } => {                "vm.started"            }            VmLifecycleEvent::VmPaused { .. } => "vm.paused",            VmLifecycleEvent::VmResumed { .. } => "vm.resumed",            VmLifecycleEvent::VmStopped { .. } | VmLifecycleEvent::VmStoppedV2 { .. } => {                "vm.stopped"            }            VmLifecycleEvent::VmStateChanged { .. } => "vm.state_changed",        }    }    fn occurred_at(&self) -> SystemTime {        match self {            VmLifecycleEvent::VmCreated { occurred_at, .. }            | VmLifecycleEvent::VmCreatedV2 { occurred_at, .. }            | VmLifecycleEvent::VmStarted { occurred_at, .. }            | VmLifecycleEvent::VmStartedV2 { occurred_at, .. }            | VmLifecycleEvent::VmPaused { occurred_at, .. }            | VmLifecycleEvent::VmResumed { occurred_at, .. }            | VmLifecycleEvent::VmStopped { occurred_at, .. }            | VmLifecycleEvent::VmStoppedV2 { occurred_at, .. }            | VmLifecycleEvent::VmStateChanged { occurred_at, .. } => *occurred_at,        }    }    fn version(&self) -> u64 {        match self {            VmLifecycleEvent::VmCreated { .. } => 1,            VmLifecycleEvent::VmCreatedV2 { .. } => 2,            VmLifecycleEvent::VmStarted { .. } => 1,            VmLifecycleEvent::VmStartedV2 { .. } => 2,            VmLifecycleEvent::VmPaused { .. } => 1,            VmLifecycleEvent::VmResumed { .. } => 1,            VmLifecycleEvent::VmStopped { .. } => 1,            VmLifecycleEvent::VmStoppedV2 { .. } => 2,            VmLifecycleEvent::VmStateChanged { .. } => 1,        }    }    fn supports_version_upgrade(&self) -> bool {        true    }}/// 内存管理事件#[derive(Debug, Clone, Serialize, Deserialize)]pub enum MemoryEvent {    /// 内存已分配 (v1)    MemoryAllocated {        vm_id: String,        addr: GuestAddr,        size: u64,        occurred_at: SystemTime,    },    /// 内存已分配 (v2 - 带内存类型)    MemoryAllocatedV2 {        vm_id: String,        addr: GuestAddr,        size: u64,        occurred_at: SystemTime,        memory_type: String,    },    /// 内存已释放    MemoryFreed {        vm_id: String,        addr: GuestAddr,        size: u64,        occurred_at: SystemTime,    },    /// 内存映射已创建    MemoryMapped {        vm_id: String,        guest_addr: GuestAddr,        host_addr: u64,        size: u64,        occurred_at: SystemTime,    },    /// 内存映射已取消    MemoryUnmapped {        vm_id: String,        guest_addr: GuestAddr,        size: u64,        occurred_at: SystemTime,    },    /// 页错误    PageFault {        vm_id: String,        addr: GuestAddr,        is_write: bool,        occurred_at: SystemTime,    },}impl DomainEvent for MemoryEvent {    fn event_type(&self) -> &'static str {        match self {            MemoryEvent::MemoryAllocated { .. } | MemoryEvent::MemoryAllocatedV2 { .. } => {                "memory.allocated"            }            MemoryEvent::MemoryFreed { .. } => "memory.freed",            MemoryEvent::MemoryMapped { .. } => "memory.mapped",            MemoryEvent::MemoryUnmapped { .. } => "memory.unmapped",            MemoryEvent::PageFault { .. } => "memory.page_fault",        }    }    fn occurred_at(&self) -> SystemTime {        match self {            MemoryEvent::MemoryAllocated { occurred_at, .. }            | MemoryEvent::MemoryAllocatedV2 { occurred_at, .. }            | MemoryEvent::MemoryFreed { occurred_at, .. }            | MemoryEvent::MemoryMapped { occurred_at, .. }            | MemoryEvent::MemoryUnmapped { occurred_at, .. }            | MemoryEvent::PageFault { occurred_at, .. } => *occurred_at,        }    }    fn version(&self) -> u64 {        match self {            MemoryEvent::MemoryAllocated { .. } => 1,            MemoryEvent::MemoryAllocatedV2 { .. } => 2,            MemoryEvent::MemoryFreed { .. } => 1,            MemoryEvent::MemoryMapped { .. } => 1,            MemoryEvent::MemoryUnmapped { .. } => 1,            MemoryEvent::PageFault { .. } => 1,        }    }    fn supports_version_upgrade(&self) -> bool {        matches!(self, MemoryEvent::MemoryAllocated { .. })    }}/// 执行引擎事件#[derive(Debug, Clone, Serialize, Deserialize)]pub enum ExecutionEvent {    /// 执行已开始    ExecutionStarted {        vm_id: String,        pc: GuestAddr,        occurred_at: SystemTime,    },    /// 执行已停止    ExecutionStopped {        vm_id: String,        pc: GuestAddr,        reason: String,        occurred_at: SystemTime,    },    /// 指令已执行    InstructionExecuted {        vm_id: String,        vcpu_id: usize,        pc: GuestAddr,        instruction: u64,        occurred_at: SystemTime,    },    /// 代码块已编译（JIT）    CodeBlockCompiled {        vm_id: String,        pc: GuestAddr,        block_size: usize,        occurred_at: SystemTime,    },    /// 热点已检测    HotspotDetected {        vm_id: String,        pc: GuestAddr,        execution_count: u64,        occurred_at: SystemTime,    },    /// vCPU已退出    VcpuExited {        vm_id: String,        vcpu_id: usize,        reason: String,        occurred_at: SystemTime,    },}impl DomainEvent for ExecutionEvent {    fn event_type(&self) -> &'static str {        match self {            ExecutionEvent::ExecutionStarted { .. } => "execution.started",            ExecutionEvent::ExecutionStopped { .. } => "execution.stopped",            ExecutionEvent::InstructionExecuted { .. } => "execution.instruction_executed",            ExecutionEvent::CodeBlockCompiled { .. } => "execution.code_block_compiled",            ExecutionEvent::HotspotDetected { .. } => "execution.hotspot_detected",            ExecutionEvent::VcpuExited { .. } => "execution.vcpu_exited",        }    }    fn occurred_at(&self) -> SystemTime {        match self {            ExecutionEvent::ExecutionStarted { occurred_at, .. }            | ExecutionEvent::ExecutionStopped { occurred_at, .. }            | ExecutionEvent::InstructionExecuted { occurred_at, .. }            | ExecutionEvent::CodeBlockCompiled { occurred_at, .. }            | ExecutionEvent::HotspotDetected { occurred_at, .. }            | ExecutionEvent::VcpuExited { occurred_at, .. } => *occurred_at,        }    }}/// 设备事件#[derive(Debug, Clone, Serialize, Deserialize)]pub enum DeviceEvent {    /// 设备已添加    DeviceAdded {        vm_id: String,        device_id: String,        device_type: String,        occurred_at: SystemTime,    },    /// 设备已移除    DeviceRemoved {        vm_id: String,        device_id: String,        occurred_at: SystemTime,    },    /// 设备中断    DeviceInterrupt {        vm_id: String,        device_id: String,        irq: u32,        occurred_at: SystemTime,    },    /// 设备I/O完成    DeviceIoCompleted {        vm_id: String,        device_id: String,        bytes_transferred: usize,        occurred_at: SystemTime,    },}impl DomainEvent for DeviceEvent {    fn event_type(&self) -> &'static str {        match self {            DeviceEvent::DeviceAdded { .. } => "device.added",            DeviceEvent::DeviceRemoved { .. } => "device.removed",            DeviceEvent::DeviceInterrupt { .. } => "device.interrupt",            DeviceEvent::DeviceIoCompleted { .. } => "device.io_completed",        }    }    fn occurred_at(&self) -> SystemTime {        match self {            DeviceEvent::DeviceAdded { occurred_at, .. }            | DeviceEvent::DeviceRemoved { occurred_at, .. }            | DeviceEvent::DeviceInterrupt { occurred_at, .. }            | DeviceEvent::DeviceIoCompleted { occurred_at, .. } => *occurred_at,        }    }}/// 快照事件#[derive(Debug, Clone, Serialize, Deserialize)]pub enum SnapshotEvent {    /// 快照已创建    SnapshotCreated {        vm_id: String,        snapshot_id: String,        snapshot_size: u64,        occurred_at: SystemTime,    },    /// 快照已恢复    SnapshotRestored {        vm_id: String,        snapshot_id: String,        occurred_at: SystemTime,    },    /// 快照已删除    SnapshotDeleted {        vm_id: String,        snapshot_id: String,        occurred_at: SystemTime,    },}impl DomainEvent for SnapshotEvent {    fn event_type(&self) -> &'static str {        match self {            SnapshotEvent::SnapshotCreated { .. } => "snapshot.created",            SnapshotEvent::SnapshotRestored { .. } => "snapshot.restored",            SnapshotEvent::SnapshotDeleted { .. } => "snapshot.deleted",        }    }    fn occurred_at(&self) -> SystemTime {        match self {            SnapshotEvent::SnapshotCreated { occurred_at, .. }            | SnapshotEvent::SnapshotRestored { occurred_at, .. }            | SnapshotEvent::SnapshotDeleted { occurred_at, .. } => *occurred_at,        }    }}/// 统一的领域事件枚举#[derive(Debug, Clone, Serialize, Deserialize)]pub enum DomainEventEnum {    VmLifecycle(VmLifecycleEvent),    Memory(MemoryEvent),    Execution(ExecutionEvent),    Device(DeviceEvent),    Snapshot(SnapshotEvent),}impl DomainEvent for DomainEventEnum {    fn event_type(&self) -> &'static str {        match self {            DomainEventEnum::VmLifecycle(e) => e.event_type(),            DomainEventEnum::Memory(e) => e.event_type(),            DomainEventEnum::Execution(e) => e.event_type(),            DomainEventEnum::Device(e) => e.event_type(),            DomainEventEnum::Snapshot(e) => e.event_type(),        }    }    fn occurred_at(&self) -> SystemTime {        match self {            DomainEventEnum::VmLifecycle(e) => e.occurred_at(),            DomainEventEnum::Memory(e) => e.occurred_at(),            DomainEventEnum::Execution(e) => e.occurred_at(),            DomainEventEnum::Device(e) => e.occurred_at(),            DomainEventEnum::Snapshot(e) => e.occurred_at(),        }    }}/// VM配置快照（用于事件）#[derive(Debug, Clone, Serialize, Deserialize)]pub struct VmConfigSnapshot {    pub guest_arch: String,    pub memory_size: u64,    pub vcpu_count: u32,    pub exec_mode: String,}impl From<&crate::VmConfig> for VmConfigSnapshot {    fn from(config: &crate::VmConfig) -> Self {        Self {            guest_arch: config.guest_arch.name().to_string(),            memory_size: config.memory_size as u64,            vcpu_count: config.vcpu_count as u32,            exec_mode: format!("{:?}", config.exec_mode),        }    }}#[cfg(test)]mod tests {    use super::*;    use crate::{GuestArch, VmConfig};    #[test]    fn test_vm_lifecycle_event_types() {        let now = SystemTime::now();        let created = VmLifecycleEvent::VmCreated {            vm_id: "test-vm".to_string(),            config: VmConfigSnapshot {                guest_arch: "riscv64".to_string(),                memory_size: 64 * 1024 * 1024,                vcpu_count: 1,                exec_mode: "Interpreter".to_string(),            },            occurred_at: now,        };        assert_eq!(created.event_type(), "vm.created");        assert_eq!(created.occurred_at(), now);        let started = VmLifecycleEvent::VmStarted {            vm_id: "test-vm".to_string(),            occurred_at: now,        };        assert_eq!(started.event_type(), "vm.started");        let paused = VmLifecycleEvent::VmPaused {            vm_id: "test-vm".to_string(),            occurred_at: now,        };        assert_eq!(paused.event_type(), "vm.paused");        let resumed = VmLifecycleEvent::VmResumed {            vm_id: "test-vm".to_string(),            occurred_at: now,        };        assert_eq!(resumed.event_type(), "vm.resumed");        let stopped = VmLifecycleEvent::VmStopped {            vm_id: "test-vm".to_string(),            reason: "Test".to_string(),            occurred_at: now,        };        assert_eq!(stopped.event_type(), "vm.stopped");        let state_changed = VmLifecycleEvent::VmStateChanged {            vm_id: "test-vm".to_string(),            from: VmLifecycleState::Created,            to: VmLifecycleState::Running,            occurred_at: now,        };        assert_eq!(state_changed.event_type(), "vm.state_changed");    }    #[test]    fn test_memory_event_types() {        let now = SystemTime::now();        let allocated = MemoryEvent::MemoryAllocated {            vm_id: "test-vm".to_string(),            addr: GuestAddr(0x1000),            size: 4096,            occurred_at: now,        };        assert_eq!(allocated.event_type(), "memory.allocated");        assert_eq!(allocated.occurred_at(), now);        let freed = MemoryEvent::MemoryFreed {            vm_id: "test-vm".to_string(),            addr: GuestAddr(0x1000),            size: 4096,            occurred_at: now,        };        assert_eq!(freed.event_type(), "memory.freed");    }    #[test]    fn test_execution_event_types() {        let now = SystemTime::now();        let started = ExecutionEvent::ExecutionStarted {            vm_id: "test-vm".to_string(),            pc: GuestAddr(0x1000),            occurred_at: now,        };        assert_eq!(started.event_type(), "execution.started");        let stopped = ExecutionEvent::ExecutionStopped {            vm_id: "test-vm".to_string(),            pc: GuestAddr(0x2000),            reason: "Breakpoint".to_string(),            occurred_at: now,        };        assert_eq!(stopped.event_type(), "execution.stopped");    }    #[test]    fn test_domain_event_enum() {        let now = SystemTime::now();        let lifecycle = DomainEventEnum::VmLifecycle(VmLifecycleEvent::VmStarted {            vm_id: "test-vm".to_string(),            occurred_at: now,        });        assert_eq!(lifecycle.event_type(), "vm.started");        let memory = DomainEventEnum::Memory(MemoryEvent::MemoryAllocated {            vm_id: "test-vm".to_string(),            addr: GuestAddr(0x1000),            size: 4096,            occurred_at: now,        });        assert_eq!(memory.event_type(), "memory.allocated");        let execution = DomainEventEnum::Execution(ExecutionEvent::ExecutionStarted {            vm_id: "test-vm".to_string(),            pc: GuestAddr(0x1000),            occurred_at: now,        });        assert_eq!(execution.event_type(), "execution.started");    }    #[test]    fn test_vm_config_snapshot_from() {        let config = VmConfig {            guest_arch: GuestArch::Riscv64,            memory_size: 128 * 1024 * 1024,            vcpu_count: 4,            exec_mode: crate::ExecMode::JIT,            ..Default::default()        };        let snapshot = VmConfigSnapshot::from(&config);        assert_eq!(snapshot.guest_arch, "riscv64");        assert_eq!(snapshot.memory_size, 128 * 1024 * 1024);        assert_eq!(snapshot.vcpu_count, 4);        assert_eq!(snapshot.exec_mode, "JIT");    }    #[test]    fn test_domain_event_version() {        let now = SystemTime::now();        let event = VmLifecycleEvent::VmStarted {            vm_id: "test-vm".to_string(),            occurred_at: now,        };        // 默认版本应该是1        assert_eq!(event.version(), 1);    }    #[test]    fn test_event_version_upgrade() {        let now = SystemTime::now();        // 创建v1事件        let v1_event = VmLifecycleEvent::VmCreated {            vm_id: "test-vm".to_string(),            config: VmConfigSnapshot {                guest_arch: "riscv64".to_string(),                memory_size: 64 * 1024 * 1024,                vcpu_count: 1,                exec_mode: "Interpreter".to_string(),            },            occurred_at: now,        };        // 验证v1版本        assert_eq!(v1_event.version(), 1);        // 升级到最新版本        let domain_event = DomainEventEnum::VmLifecycle(v1_event);        let upgraded = EventVersionMigrator::migrate_to_latest(domain_event).unwrap();        // 验证升级结果        match upgraded {            DomainEventEnum::VmLifecycle(VmLifecycleEvent::VmCreatedV2 {                vm_id,                created_by,                ..            }) => {                assert_eq!(vm_id, "test-vm");                assert_eq!(created_by, "system");            }            _ => panic!("Expected VmCreatedV2"),        }    }    #[test]    fn test_memory_event_version_upgrade() {        let now = SystemTime::now();        // 创建v1内存事件        let v1_event = MemoryEvent::MemoryAllocated {            vm_id: "test-vm".to_string(),            addr: GuestAddr(0x1000),            size: 4096,            occurred_at: now,        };        // 验证v1版本        assert_eq!(v1_event.version(), 1);        // 升级到最新版本        let domain_event = DomainEventEnum::Memory(v1_event);        let upgraded = EventVersionMigrator::migrate_to_latest(domain_event).unwrap();        // 验证升级结果        match upgraded {            DomainEventEnum::Memory(MemoryEvent::MemoryAllocatedV2 {                vm_id, memory_type, ..            }) => {                assert_eq!(vm_id, "test-vm");                assert_eq!(memory_type, "heap");            }            _ => panic!("Expected MemoryAllocatedV2"),        }    }    #[test]    fn test_event_migration_tool() {        let tool = EventVersionMigrator::create_migration_tool();        let now = SystemTime::now();        // 创建混合版本的事件列表        let events = vec![            DomainEventEnum::VmLifecycle(VmLifecycleEvent::VmCreated {                vm_id: "vm1".to_string(),                config: VmConfigSnapshot {                    guest_arch: "riscv64".to_string(),                    memory_size: 64 * 1024 * 1024,                    vcpu_count: 1,                    exec_mode: "Interpreter".to_string(),                },                occurred_at: now,            }),            DomainEventEnum::VmLifecycle(VmLifecycleEvent::VmStartedV2 {                vm_id: "vm1".to_string(),                occurred_at: now,                startup_time_ms: 100,            }),        ];        // 生成升级报告        let report = tool.generate_upgrade_report(&events);        assert_eq!(report.total_events, 2);        assert_eq!(report.outdated_events, 1); // VmCreated是v1，需要升级        assert_eq!(report.upgradeable_events, 1);        assert_eq!(report.incompatible_events, 0);        // 验证问题详情        assert_eq!(report.issues.len(), 1);        assert_eq!(report.issues[0].event_type, "vm.created");        assert_eq!(report.issues[0].current_version, 1);        assert_eq!(report.issues[0].latest_version, 2);        // 执行迁移        let migrated = tool.migrate_events(events).unwrap();        assert_eq!(migrated.len(), 2);        // 验证第一个事件已升级        match &migrated[0] {            DomainEventEnum::VmLifecycle(VmLifecycleEvent::VmCreatedV2 { .. }) => {}            _ => panic!("Expected VmCreatedV2"),        }    }    #[test]    fn test_version_compatibility_check() {        // 测试兼容版本        assert!(EventVersionMigrator::is_version_compatible("vm.created", 1));        assert!(EventVersionMigrator::is_version_compatible("vm.created", 2));        // 测试不兼容版本        assert!(!EventVersionMigrator::is_version_compatible(            "vm.created",            3        ));    }}