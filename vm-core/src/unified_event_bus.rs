//! 统一事件总线//!//! 提供统一的事件发布订阅机制，整合AsyncEventBus和DomainEventBus的优点，//! 支持同步、异步和批处理等多种处理模式，具备高性能、可扩展和易用性。use crate::{VmError, VmResult};#[cfg(feature = "std")]use crate::jit::domain_events::{DomainEvent, DomainEventEnum, EventVersionMigrator};use crate::jit::domain_event_bus::{EventFilter, EventHandler, EventSubscriptionId};use std::collections::{HashMap, VecDeque};use std::sync::{    Arc, Mutex, RwLock,    atomic::{AtomicBool, AtomicU64, Ordering},};use std::time::{Duration, SystemTime};#[cfg(feature = "async")]use tokio::sync::mpsc;#[cfg(feature = "async")]use tokio::time::sleep;/// 处理模式#[derive(Debug, Clone, PartialEq, Eq, Hash)]pub enum ProcessingMode {    /// 同步处理    Sync,    /// 异步处理    Async,    /// 批处理    Batch,    /// 自适应（根据负载自动选择）    Adaptive,}impl Default for ProcessingMode {    fn default() -> Self {        ProcessingMode::Sync    }}/// 订阅选项pub struct SubscriptionOptions {    /// 事件过滤器    pub filter: Option<Box<dyn EventFilter>>,    /// 处理模式    pub mode: ProcessingMode,    /// 重试策略    pub retry_policy: Option<Box<dyn RetryPolicy>>,    /// 是否启用批处理    pub batch_processing: bool,    /// 批处理大小    pub batch_size: Option<usize>,}impl Default for SubscriptionOptions {    fn default() -> Self {        Self {            filter: None,            mode: ProcessingMode::Sync,            retry_policy: None,            batch_processing: false,            batch_size: None,        }    }}/// 增强的事件处理器接口pub trait EnhancedEventHandler: Send + Sync {    /// 处理事件    fn handle(&self, event: &dyn DomainEvent) -> VmResult<()>;        /// 异步处理事件    #[cfg(feature = "async")]    async fn handle_async(&self, event: &dyn DomainEvent) -> VmResult<()>;        /// 获取处理器优先级    fn priority(&self) -> u32 { 100 }        /// 获取处理器名称    fn name(&self) -> &str;        /// 是否支持异步处理    fn supports_async(&self) -> bool { false }}/// 事件处理器适配器pub struct EventHandlerAdapter {    handler: Box<dyn EventHandler>,    name: String,}impl EventHandlerAdapter {    pub fn new(handler: Box<dyn EventHandler>) -> Self {        Self {            name: format!("adapter_{}", &handler as *const _ as usize),            handler,        }    }}impl EnhancedEventHandler for EventHandlerAdapter {    fn handle(&self, event: &dyn DomainEvent) -> VmResult<()> {        self.handler.handle(event)    }        #[cfg(feature = "async")]    async fn handle_async(&self, event: &dyn DomainEvent) -> VmResult<()> {        // 对于同步处理器，在异步上下文中直接调用        self.handle(event)    }        fn priority(&self) -> u32 {        self.handler.priority()    }        fn name(&self) -> &str {        &self.name    }}/// 重试策略pub trait RetryPolicy: Send + Sync {    /// 检查是否应该重试    fn should_retry(&self, error: &VmError, attempt: u32) -> bool;    /// 获取重试延迟    fn delay(&self, attempt: u32) -> Duration;    /// 获取最大重试次数    fn max_retries(&self) -> u32;}/// 指数退避重试策略#[derive(Debug, Clone)]pub struct ExponentialBackoffRetryPolicy {    max_retries: u32,    base_delay: Duration,    max_delay: Duration,    multiplier: f64,}impl ExponentialBackoffRetryPolicy {    pub fn new(max_retries: u32, base_delay: Duration, max_delay: Duration) -> Self {        Self {            max_retries,            base_delay,            max_delay,            multiplier: 2.0,        }    }        pub fn with_multiplier(mut self, multiplier: f64) -> Self {        self.multiplier = multiplier;        self    }}impl RetryPolicy for ExponentialBackoffRetryPolicy {    fn should_retry(&self, error: &VmError, attempt: u32) -> bool {        attempt < self.max_retries && self.is_retryable_error(error)    }        fn delay(&self, attempt: u32) -> Duration {        let delay = Duration::from_millis((self.base_delay.as_millis() as f64 * self.multiplier.powi(attempt as i32)) as u64);        delay.min(self.max_delay)    }        fn max_retries(&self) -> u32 {        self.max_retries    }}impl ExponentialBackoffRetryPolicy {    fn is_retryable_error(&self, error: &VmError) -> bool {        match error {            VmError::Core(_) => true,            VmError::Io(_) => false, // IO错误通常不可重试            _ => true,        }    }}/// 事件过滤器链pub struct FilterChain {    filters: Vec<Box<dyn EventFilter>>,}impl std::fmt::Debug for FilterChain {    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {        write!(f, "FilterChain {{ filters: {} }}", self.filters.len())    }}impl FilterChain {    pub fn new() -> Self {        Self {            filters: Vec::new(),        }    }        pub fn add_filter(&mut self, filter: Box<dyn EventFilter>) {        self.filters.push(filter);    }        pub fn matches(&self, event: &dyn DomainEvent) -> bool {        self.filters.iter().all(|filter| filter.matches(event))    }}impl Default for FilterChain {    fn default() -> Self {        Self::new()    }}/// 事件指标#[derive(Debug, Clone)]pub struct EventMetrics {    pub total_events_processed: u64,    pub total_events_failed: u64,    pub average_processing_time: Duration,    pub events_per_second: f64,    pub error_rate: f64,    pub queue_size: usize,    pub processing_latency_p50: Duration,    pub processing_latency_p95: Duration,    pub processing_latency_p99: Duration,}impl Default for EventMetrics {    fn default() -> Self {        Self {            total_events_processed: 0,            total_events_failed: 0,            average_processing_time: Duration::ZERO,            events_per_second: 0.0,            error_rate: 0.0,            queue_size: 0,            processing_latency_p50: Duration::ZERO,            processing_latency_p95: Duration::ZERO,            processing_latency_p99: Duration::ZERO,        }    }}/// 指标收集器pub trait MetricsCollector: Send + Sync {    fn record_event_processed(&self, event_type: &str, duration: Duration);    fn record_event_failed(&self, event_type: &str, error: &VmError);    fn record_batch_processed(&self, batch_size: usize, duration: Duration);    fn get_metrics(&self) -> EventMetrics;}/// 默认指标收集器#[derive(Debug)]pub struct DefaultMetricsCollector {    total_processed: AtomicU64,    total_failed: AtomicU64,    processing_times: Mutex<Vec<Duration>>,    event_types: RwLock<HashMap<String, AtomicU64>>,    last_reset: AtomicU64,}impl DefaultMetricsCollector {    pub fn new() -> Self {        Self {            total_processed: AtomicU64::new(0),            total_failed: AtomicU64::new(0),            processing_times: Mutex::new(Vec::new()),            event_types: RwLock::new(HashMap::new()),            last_reset: AtomicU64::new(                SystemTime::now()                    .duration_since(SystemTime::UNIX_EPOCH)                    .unwrap_or_default()                    .as_secs(),            ),        }    }        fn calculate_percentiles(&self) -> (Duration, Duration, Duration) {        let times = self.processing_times.lock().unwrap();        if times.is_empty() {            return (Duration::ZERO, Duration::ZERO, Duration::ZERO);        }                let mut sorted_times = times.clone();        sorted_times.sort();                let len = sorted_times.len();        let p50 = sorted_times[len * 50 / 100];        let p95 = sorted_times[len * 95 / 100];        let p99 = sorted_times[len * 99 / 100];                (p50, p95, p99)    }}impl MetricsCollector for DefaultMetricsCollector {    fn record_event_processed(&self, event_type: &str, duration: Duration) {        self.total_processed.fetch_add(1, Ordering::Relaxed);                // 记录处理时间（限制最大数量以避免内存泄漏）        {            let mut times = self.processing_times.lock().unwrap();            times.push(duration);            if times.len() > 10000 {                times.remove(0);            }        }                // 记录事件类型统计        {            let mut types = self.event_types.write().unwrap();            let counter = types.entry(event_type.to_string()).or_insert_with(|| AtomicU64::new(0));            counter.fetch_add(1, Ordering::Relaxed);        }    }        fn record_event_failed(&self, event_type: &str, _error: &VmError) {        self.total_failed.fetch_add(1, Ordering::Relaxed);                // 记录失败事件类型        let mut types = self.event_types.write().unwrap();        types.entry(event_type.to_string()).or_insert_with(|| AtomicU64::new(0));    }        fn record_batch_processed(&self, batch_size: usize, duration: Duration) {        self.total_processed.fetch_add(batch_size as u64, Ordering::Relaxed);                // 记录批处理时间        {            let mut times = self.processing_times.lock().unwrap();            times.push(duration);            if times.len() > 10000 {                times.remove(0);            }        }    }        fn get_metrics(&self) -> EventMetrics {        let total_processed = self.total_processed.load(Ordering::Relaxed);        let total_failed = self.total_failed.load(Ordering::Relaxed);                let (p50, p95, p99) = self.calculate_percentiles();                let average_processing_time = {            let times = self.processing_times.lock().unwrap();            if times.is_empty() {                Duration::ZERO            } else {                let total: Duration = times.iter().sum();                total / times.len() as u32            }        };                let events_per_second = {            let now = SystemTime::now()                .duration_since(SystemTime::UNIX_EPOCH)                .unwrap_or_default()                .as_secs();            let last_reset = self.last_reset.load(Ordering::Relaxed);            let elapsed_seconds = now.saturating_sub(last_reset);                        if elapsed_seconds > 0 {                total_processed as f64 / elapsed_seconds as f64            } else {                0.0            }        };                let total_events = total_processed + total_failed;        let error_rate = if total_events > 0 {            total_failed as f64 / total_events as f64        } else {            0.0        };                EventMetrics {            total_events_processed: total_processed,            total_events_failed: total_failed,            average_processing_time,            events_per_second,            error_rate,            queue_size: 0, // 由具体实现提供            processing_latency_p50: p50,            processing_latency_p95: p95,            processing_latency_p99: p99,        }    }}impl Default for DefaultMetricsCollector {    fn default() -> Self {        Self::new()    }}/// 订阅信息pub struct Subscription {    pub id: EventSubscriptionId,    pub event_type: String,    pub handler: Box<dyn EnhancedEventHandler>,    pub filter: Option<Box<dyn EventFilter>>,    pub priority: u32,    pub mode: ProcessingMode,    pub retry_policy: Option<Box<dyn RetryPolicy>>,    pub batch_processing: bool,    pub batch_size: Option<usize>,    pub created_at: SystemTime,}/// 订阅注册表pub struct SubscriptionRegistry {    subscriptions: Arc<RwLock<HashMap<String, Vec<Subscription>>>>,    next_id: AtomicU64,}impl SubscriptionRegistry {    pub fn new() -> Self {        Self {            subscriptions: Arc::new(RwLock::new(HashMap::new())),            next_id: AtomicU64::new(1),        }    }        /// 添加订阅    pub fn add_subscription(        &self,        event_type: &str,        handler: Box<dyn EnhancedEventHandler>,        options: SubscriptionOptions,    ) -> VmResult<EventSubscriptionId> {        let id = self.next_id.fetch_add(1, Ordering::Relaxed);        let priority = handler.priority();                let subscription = Subscription {            id,            event_type: event_type.to_string(),            handler,            filter: options.filter,            priority,            mode: options.mode,            retry_policy: options.retry_policy,            batch_processing: options.batch_processing,            batch_size: options.batch_size,            created_at: SystemTime::now(),        };                let mut subscriptions = self.subscriptions.write().map_err(|_| {            VmError::Core(crate::CoreError::Concurrency {                message: "Failed to acquire subscriptions lock".to_string(),                operation: "add_subscription".to_string(),            })        })?;                subscriptions            .entry(event_type.to_string())            .or_insert_with(Vec::new)            .push(subscription);                Ok(id)    }        /// 移除订阅    pub fn remove_subscription(&self, subscription_id: EventSubscriptionId) -> VmResult<()> {        let mut subscriptions = self.subscriptions.write().map_err(|_| {            VmError::Core(crate::CoreError::Concurrency {                message: "Failed to acquire subscriptions lock".to_string(),                operation: "remove_subscription".to_string(),            })        })?;                // 查找并移除订阅        for (_, subs) in subscriptions.iter_mut() {            subs.retain(|sub| sub.id != subscription_id);        }                // 清理空的事件类型        subscriptions.retain(|_, subs| !subs.is_empty());                Ok(())    }        /// 查找匹配的订阅    pub fn find_subscriptions(&self, event_type: &str) -> VmResult<Vec<Subscription>> {        let subscriptions = self.subscriptions.read().map_err(|_| {            VmError::Core(crate::CoreError::Concurrency {                message: "Failed to acquire subscriptions lock".to_string(),                operation: "find_subscriptions".to_string(),            })        })?;                let mut matching_subs = Vec::new();                // 查找完全匹配的订阅        if let Some(subs) = subscriptions.get(event_type) {            for sub in subs {                matching_subs.push(Subscription {                    id: sub.id,                    event_type: sub.event_type.clone(),                    handler: self.clone_handler(&sub.handler),                    filter: None, // 简化实现，不克隆过滤器                    priority: sub.priority,                    mode: sub.mode.clone(),                    retry_policy: None, // 简化实现，不克隆重试策略                    batch_processing: sub.batch_processing,                    batch_size: sub.batch_size,                    created_at: sub.created_at,                });            }        }                // 按优先级排序        matching_subs.sort_by_key(|sub| sub.priority);                Ok(matching_subs)    }        /// 获取统计信息    pub fn get_stats(&self) -> EventBusStats {        let subscriptions = self.subscriptions.read().ok();        let total_subscriptions = subscriptions            .as_ref()            .map(|s| s.values().map(|v| v.len()).sum())            .unwrap_or(0);        let event_types = subscriptions.as_ref().map(|s| s.len()).unwrap_or(0);                EventBusStats {            total_subscriptions,            event_types,        }    }        /// 克隆事件处理器（简化实现）    fn clone_handler(&self, handler: &Box<dyn EnhancedEventHandler>) -> Box<dyn EnhancedEventHandler> {        // 注意：这是一个简化的实现，实际中可能需要更复杂的克隆逻辑        // 或者使用Arc<dyn EnhancedEventHandler>来共享处理器        Box::new(CloneHandlerAdapter {            name: handler.name().to_string(),            priority: handler.priority(),            supports_async: handler.supports_async(),        })    }}/// 克隆处理器适配器（简化实现）struct CloneHandlerAdapter {    name: String,    priority: u32,    supports_async: bool,}impl EnhancedEventHandler for CloneHandlerAdapter {    fn handle(&self, _event: &dyn DomainEvent) -> VmResult<()> {        Ok(()) // 简化实现    }        #[cfg(feature = "async")]    async fn handle_async(&self, _event: &dyn DomainEvent) -> VmResult<()> {        Ok(()) // 简化实现    }        fn priority(&self) -> u32 {        self.priority    }        fn name(&self) -> &str {        &self.name    }        fn supports_async(&self) -> bool {        self.supports_async    }}/// 事件处理器接口pub trait EventProcessor: Send + Sync {    /// 处理单个事件    fn process(&self, event: &DomainEventEnum, subscription: &Subscription) -> VmResult<()>;        /// 批量处理事件    fn process_batch(&self, events: &[DomainEventEnum], subscription: &Subscription) -> VmResult<()>;        /// 是否支持批处理    fn supports_batch_processing(&self) -> bool { false }}/// 同步事件处理器pub struct SyncProcessor {    filter_chain: FilterChain,    metrics: Arc<dyn MetricsCollector>,}impl SyncProcessor {    pub fn new(metrics: Arc<dyn MetricsCollector>) -> Self {        Self {            filter_chain: FilterChain::new(),            metrics,        }    }        pub fn with_filter_chain(mut self, filter_chain: FilterChain) -> Self {        self.filter_chain = filter_chain;        self    }}impl EventProcessor for SyncProcessor {    fn process(&self, event: &DomainEventEnum, subscription: &Subscription) -> VmResult<()> {        let start_time = SystemTime::now();                // 应用过滤器        if let Some(filter) = &subscription.filter {            if !filter.matches(event) {                return Ok(());            }        }                // 应用过滤器链        if !self.filter_chain.matches(event) {            return Ok(());        }                // 执行处理器（带重试）        let mut attempt = 0;        loop {            match subscription.handler.handle(event) {                Ok(()) => {                    let duration = start_time.elapsed().unwrap_or(Duration::ZERO);                    self.metrics.record_event_processed(event.event_type(), duration);                    return Ok(());                }                Err(e) => {                    attempt += 1;                                        // 检查是否应该重试                    let should_retry = subscription.retry_policy                        .as_ref()                        .map(|policy| policy.should_retry(&e, attempt))                        .unwrap_or(false);                                        if should_retry {                        let delay = subscription.retry_policy                            .as_ref()                            .map(|policy| policy.delay(attempt))                            .unwrap_or(Duration::from_millis(100));                                                std::thread::sleep(delay);                    } else {                        let _duration = start_time.elapsed().unwrap_or(Duration::ZERO);                        self.metrics.record_event_failed(event.event_type(), &e);                        return Err(e);                    }                }            }        }    }        fn process_batch(&self, events: &[DomainEventEnum], subscription: &Subscription) -> VmResult<()> {        let start_time = SystemTime::now();                for event in events {            self.process(event, subscription)?;        }                let duration = start_time.elapsed().unwrap_or(Duration::ZERO);        self.metrics.record_batch_processed(events.len(), duration);                Ok(())    }}/// 队列中的事件#[derive(Debug, Clone)]struct QueuedEvent {    /// 事件    event: DomainEventEnum,    /// 订阅ID    subscription_id: EventSubscriptionId,    /// 重试次数    retry_count: u32,    /// 入队时间    enqueued_at: SystemTime,}/// 异步事件处理器pub struct AsyncProcessor {    event_queue: Arc<Mutex<VecDeque<QueuedEvent>>>,    batch_size: usize,    batch_interval_ms: u64,    max_retries: u32,    is_running: Arc<AtomicBool>,    processed_count: Arc<AtomicU64>,    failed_count: Arc<AtomicU64>,    metrics: Arc<dyn MetricsCollector>,    #[cfg(feature = "async")]    sender: Option<mpsc::UnboundedSender<QueuedEvent>>,}impl AsyncProcessor {    pub fn new(metrics: Arc<dyn MetricsCollector>) -> Self {        Self {            event_queue: Arc::new(Mutex::new(VecDeque::new())),            batch_size: 100,            batch_interval_ms: 10,            max_retries: 3,            is_running: Arc::new(AtomicBool::new(false)),            processed_count: Arc::new(AtomicU64::new(0)),            failed_count: Arc::new(AtomicU64::new(0)),            metrics,            #[cfg(feature = "async")]            sender: None,        }    }        pub fn with_config(mut self, batch_size: usize, batch_interval_ms: u64, max_retries: u32) -> Self {        self.batch_size = batch_size;        self.batch_interval_ms = batch_interval_ms;        self.max_retries = max_retries;        self    }        /// 启动异步处理    #[cfg(feature = "async")]    pub fn start(&mut self) -> VmResult<()> {        if self.is_running.load(Ordering::Acquire) {            return Ok(()); // 已经在运行        }                self.is_running.store(true, Ordering::Release);                let (sender, mut receiver) = mpsc::unbounded_channel();        self.sender = Some(sender);                let batch_size = self.batch_size;        let batch_interval = Duration::from_millis(self.batch_interval_ms);        let max_retries = self.max_retries;        let is_running = Arc::clone(&self.is_running);        let processed_count = Arc::clone(&self.processed_count);        let failed_count = Arc::clone(&self.failed_count);        let metrics = Arc::clone(&self.metrics);                tokio::spawn(async move {            let mut batch = Vec::new();            let mut last_batch_time = SystemTime::now();                        while is_running.load(Ordering::Acquire) {                // 接收事件                tokio::select! {                    event = receiver.recv() => {                        if let Some(queued_event) = event {                            batch.push(queued_event);                        } else {                            // 通道关闭，退出                            break;                        }                    }                    _ = sleep(batch_interval) => {                        // 批处理间隔到达                    }                }                                // 检查是否需要处理批次                let should_process = batch.len() >= batch_size                    || (batch.len() > 0                        && last_batch_time.elapsed().unwrap_or(Duration::ZERO) >= batch_interval);                                if should_process {                    // 处理批次                    for queued_event in batch.drain(..) {                        // 这里应该调用订阅处理器，简化实现                        processed_count.fetch_add(1, Ordering::Relaxed);                    }                    last_batch_time = SystemTime::now();                }            }        });                Ok(())    }        /// 启动异步处理（非async版本）    #[cfg(not(feature = "async"))]    pub fn start(&mut self) -> VmResult<()> {        // 非async版本，直接返回成功        self.is_running.store(true, Ordering::Release);        Ok(())    }        /// 停止异步处理    pub fn stop(&mut self) {        self.is_running.store(false, Ordering::Release);        #[cfg(feature = "async")]        {            if let Some(sender) = self.sender.take() {                drop(sender);            }        }    }        /// 异步发布事件    #[cfg(feature = "async")]    pub fn publish_async(&self, event: DomainEventEnum, subscription_id: EventSubscriptionId) -> VmResult<()> {        if !self.is_running.load(Ordering::Acquire) {            // 如果异步处理未启动，回退到同步处理            return Err(VmError::Core(crate::CoreError::InvalidState {                message: "Async processor is not running".to_string(),                current: "stopped".to_string(),                expected: "running".to_string(),            }));        }                let queued_event = QueuedEvent {            event,            subscription_id,            retry_count: 0,            enqueued_at: SystemTime::now(),        };                if let Some(ref sender) = self.sender {            sender.send(queued_event).map_err(|_| {                VmError::Core(crate::CoreError::Internal {                    message: "Failed to send event to async queue".to_string(),                    module: "async_processor".to_string(),                })            })?;        }                Ok(())    }        /// 异步发布事件（非async版本）    #[cfg(not(feature = "async"))]    pub fn publish_async(&self, _event: DomainEventEnum, _subscription_id: EventSubscriptionId) -> VmResult<()> {        Err(VmError::Core(crate::CoreError::Internal {            message: "Async processing is not available without async feature".to_string(),            module: "async_processor".to_string(),        }))    }        /// 获取统计信息    pub fn get_stats(&self) -> AsyncProcessorStats {        AsyncProcessorStats {            processed_count: self.processed_count.load(Ordering::Relaxed),            failed_count: self.failed_count.load(Ordering::Relaxed),            queue_size: self.event_queue.lock().map(|q| q.len()).unwrap_or(0),            is_running: self.is_running.load(Ordering::Acquire),        }    }}impl EventProcessor for AsyncProcessor {    fn process(&self, _event: &DomainEventEnum, _subscription: &Subscription) -> VmResult<()> {        #[cfg(feature = "async")]        {            self.publish_async(event.clone(), subscription.id)        }        #[cfg(not(feature = "async"))]        {            Err(VmError::Core(crate::CoreError::Internal {                message: "Async processing is not available without async feature".to_string(),                module: "async_processor".to_string(),            }))        }    }        fn process_batch(&self, events: &[DomainEventEnum], subscription: &Subscription) -> VmResult<()> {        for event in events {            self.process(event, subscription)?;        }        Ok(())    }        fn supports_batch_processing(&self) -> bool {        true    }}/// 异步处理器统计#[derive(Debug, Clone)]pub struct AsyncProcessorStats {    pub processed_count: u64,    pub failed_count: u64,    pub queue_size: usize,    pub is_running: bool,}/// 批处理配置#[derive(Debug, Clone)]pub struct BatchConfig {    pub default_batch_size: usize,    pub min_batch_size: usize,    pub max_batch_size: usize,    pub batch_interval_ms: u64,    pub adaptive_batching: bool,}impl Default for BatchConfig {    fn default() -> Self {        Self {            default_batch_size: 100,            min_batch_size: 10,            max_batch_size: 1000,            batch_interval_ms: 10,            adaptive_batching: true,        }    }}/// 批事件处理器pub struct BatchProcessor {    config: BatchConfig,    event_buffer: Arc<Mutex<HashMap<EventSubscriptionId, VecDeque<DomainEventEnum>>>>,    last_flush_time: Arc<Mutex<HashMap<EventSubscriptionId, SystemTime>>>,    metrics: Arc<dyn MetricsCollector>,}impl BatchProcessor {    pub fn new(config: BatchConfig, metrics: Arc<dyn MetricsCollector>) -> Self {        Self {            config,            event_buffer: Arc::new(Mutex::new(HashMap::new())),            last_flush_time: Arc::new(Mutex::new(HashMap::new())),            metrics,        }    }        /// 刷新批次    fn flush_batch(&self, subscription_id: EventSubscriptionId, subscription: &Subscription) -> VmResult<()> {        let mut buffer = self.event_buffer.lock().unwrap();        let mut last_flush = self.last_flush_time.lock().unwrap();                if let Some(events) = buffer.get_mut(&subscription_id) {            if events.is_empty() {                return Ok(());            }                        let batch: Vec<DomainEventEnum> = events.drain(..).collect();            drop(buffer); // 释放锁                        let start_time = SystemTime::now();                        // 处理批次            for event in &batch {                subscription.handler.handle(event)?;            }                        let duration = start_time.elapsed().unwrap_or(Duration::ZERO);            self.metrics.record_batch_processed(batch.len(), duration);                        last_flush.insert(subscription_id, SystemTime::now());        }                Ok(())    }}impl EventProcessor for BatchProcessor {    fn process(&self, event: &DomainEventEnum, subscription: &Subscription) -> VmResult<()> {        let subscription_id = subscription.id;        let batch_size = subscription.batch_size.unwrap_or(self.config.default_batch_size);                // 添加到批处理缓冲区        {            let mut buffer = self.event_buffer.lock().unwrap();            let events = buffer.entry(subscription_id).or_insert_with(VecDeque::new);            events.push_back(event.clone());        }                // 检查是否需要刷新        let should_flush = {            let buffer = self.event_buffer.lock().unwrap();            let events = buffer.get(&subscription_id);                        let size_exceeded = events.map(|e| e.len() >= batch_size).unwrap_or(false);                        let time_exceeded = {                let last_flush = self.last_flush_time.lock().unwrap();                let last_time = last_flush.get(&subscription_id);                match last_time {                    Some(time) => {                        time.elapsed().unwrap_or(Duration::ZERO) >= Duration::from_millis(self.config.batch_interval_ms)                    }                    None => true, // 第一次立即处理                }            };                        size_exceeded || time_exceeded        };                if should_flush {            self.flush_batch(subscription_id, subscription)?;        }                Ok(())    }        fn process_batch(&self, events: &[DomainEventEnum], subscription: &Subscription) -> VmResult<()> {        let start_time = SystemTime::now();                for event in events {            subscription.handler.handle(event)?;        }                let duration = start_time.elapsed().unwrap_or(Duration::ZERO);        self.metrics.record_batch_processed(events.len(), duration);                Ok(())    }        fn supports_batch_processing(&self) -> bool {        true    }}/// 事件分发器pub struct EventDispatcher {    processors: HashMap<ProcessingMode, Box<dyn EventProcessor>>,    filter_chain: FilterChain,    metrics: Arc<dyn MetricsCollector>,}impl EventDispatcher {    pub fn new(metrics: Arc<dyn MetricsCollector>) -> Self {        Self {            processors: HashMap::new(),            filter_chain: FilterChain::new(),            metrics,        }    }        /// 添加处理器    pub fn add_processor(&mut self, mode: ProcessingMode, processor: Box<dyn EventProcessor>) {        self.processors.insert(mode, processor);    }        /// 分发事件    pub fn dispatch(&self, event: &DomainEventEnum, subscriptions: &[Subscription]) -> VmResult<()> {        let start_time = SystemTime::now();        let mut total_errors = 0;                for subscription in subscriptions {            // 应用过滤器            if let Some(filter) = &subscription.filter {                if !filter.matches(event) {                    continue;                }            }                        // 应用过滤器链            if !self.filter_chain.matches(event) {                continue;            }                        // 获取处理器            let processor = self.processors.get(&subscription.mode)                .or_else(|| self.processors.get(&ProcessingMode::Sync))                .ok_or_else(|| {                    VmError::Core(crate::CoreError::Internal {                        message: format!("No processor found for mode {:?}", subscription.mode),                        module: "event_dispatcher".to_string(),                    })                })?;                        // 处理事件            if let Err(e) = processor.process(event, subscription) {                total_errors += 1;                self.metrics.record_event_failed(event.event_type(), &e);                                // 记录错误但继续处理其他订阅者                eprintln!("Event processing error for subscription {}: {:?}", subscription.id, e);            }        }                let duration = start_time.elapsed().unwrap_or(Duration::ZERO);        self.metrics.record_event_processed(event.event_type(), duration);                if total_errors > 0 {            return Err(VmError::Core(crate::CoreError::Internal {                message: format!("{} out of {} subscriptions failed", total_errors, subscriptions.len()),                module: "event_dispatcher".to_string(),            }));        }                Ok(())    }        /// 异步分发事件    #[cfg(feature = "async")]    pub async fn dispatch_async(&self, event: &DomainEventEnum, subscriptions: &[Subscription]) -> VmResult<()> {        // 简化实现：使用tokio spawn并行处理        let mut handles = Vec::new();                for subscription in subscriptions {            // 应用过滤器            if let Some(filter) = &subscription.filter {                if !filter.matches(event) {                    continue;                }            }                        // 应用过滤器链            if !self.filter_chain.matches(event) {                continue;            }                        // 获取处理器            let processor = self.processors.get(&subscription.mode)                .or_else(|| self.processors.get(&ProcessingMode::Sync))                .ok_or_else(|| {                    VmError::Core(crate::CoreError::Internal {                        message: format!("No processor found for mode {:?}", subscription.mode),                        module: "event_dispatcher".to_string(),                    })                })?;                        let event = event.clone();            let subscription = Subscription {                id: subscription.id,                event_type: subscription.event_type.clone(),                handler: self.clone_handler(&subscription.handler),                filter: None, // 简化实现，不克隆过滤器                priority: subscription.priority,                mode: subscription.mode.clone(),                retry_policy: None, // 简化实现，不克隆重试策略                batch_processing: subscription.batch_processing,                batch_size: subscription.batch_size,                created_at: subscription.created_at,            };                        let handle = tokio::spawn(async move {                processor.process(&event, &subscription)            });                        handles.push(handle);        }                // 等待所有处理完成        let mut total_errors = 0;        for handle in handles {            match handle.await {                Ok(Ok(())) => {}                Ok(Err(e)) => {                    total_errors += 1;                    eprintln!("Async event processing error: {:?}", e);                }                Err(e) => {                    total_errors += 1;                    eprintln!("Task join error: {:?}", e);                }            }        }                if total_errors > 0 {            return Err(VmError::Core(crate::CoreError::Internal {                message: format!("{} async subscriptions failed", total_errors),                module: "event_dispatcher".to_string(),            }));        }                Ok(())    }        /// 异步分发事件（非async版本）    #[cfg(not(feature = "async"))]    pub async fn dispatch_async(&self, event: &DomainEventEnum, subscriptions: &[Subscription]) -> VmResult<()> {        // 非async版本，回退到同步分发        self.dispatch(event, subscriptions)    }        /// 批量分发事件    pub fn dispatch_batch(&self, events: &[DomainEventEnum], subscriptions: &[Subscription]) -> VmResult<()> {        let start_time = SystemTime::now();        let mut total_errors = 0;                for subscription in subscriptions {            // 应用过滤器            if let Some(filter) = &subscription.filter {                if !events.iter().any(|e| filter.matches(e)) {                    continue;                }            }                        // 应用过滤器链            if !events.iter().any(|e| self.filter_chain.matches(e)) {                continue;            }                        // 获取处理器            let processor = self.processors.get(&subscription.mode)                .or_else(|| self.processors.get(&ProcessingMode::Sync))                .ok_or_else(|| {                    VmError::Core(crate::CoreError::Internal {                        message: format!("No processor found for mode {:?}", subscription.mode),                        module: "event_dispatcher".to_string(),                    })                })?;                        // 处理事件            if let Err(e) = processor.process_batch(events, subscription) {                total_errors += 1;                self.metrics.record_event_failed(events[0].event_type(), &e);                                // 记录错误但继续处理其他订阅者                eprintln!("Batch event processing error for subscription {}: {:?}", subscription.id, e);            }        }                let duration = start_time.elapsed().unwrap_or(Duration::ZERO);        self.metrics.record_batch_processed(events.len(), duration);                if total_errors > 0 {            return Err(VmError::Core(crate::CoreError::Internal {                message: format!("{} out of {} batch subscriptions failed", total_errors, subscriptions.len()),                module: "event_dispatcher".to_string(),            }));        }                Ok(())    }        /// 克隆事件处理器（简化实现）    fn clone_handler(&self, handler: &Box<dyn EnhancedEventHandler>) -> Box<dyn EnhancedEventHandler> {        // 注意：这是一个简化的实现，实际中可能需要更复杂的克隆逻辑        Box::new(CloneHandlerAdapter {            name: handler.name().to_string(),            priority: handler.priority(),            supports_async: handler.supports_async(),        })    }}/// 事件总线配置#[derive(Debug, Clone)]pub struct EventBusConfig {    /// 默认处理模式    pub default_mode: ProcessingMode,    /// 批处理配置    pub batch_config: BatchConfig,    /// 异步处理配置    pub async_config: AsyncConfig,    /// 重试配置    pub retry_config: RetryConfig,    /// 性能监控配置    pub metrics_config: MetricsConfig,}/// 异步处理配置#[derive(Debug, Clone)]pub struct AsyncConfig {    /// 异步队列大小    pub queue_size: usize,    /// 工作线程数    pub worker_threads: Option<usize>,    /// 是否启用自适应调度    pub adaptive_scheduling: bool,}/// 重试配置#[derive(Debug, Clone)]pub struct RetryConfig {    /// 默认最大重试次数    pub max_retries: u32,    /// 基础延迟    pub base_delay_ms: u64,    /// 最大延迟    pub max_delay_ms: u64,    /// 退避倍数    pub backoff_multiplier: f64,}/// 性能监控配置#[derive(Debug, Clone)]pub struct MetricsConfig {    /// 是否启用详细指标    pub detailed_metrics: bool,    /// 指标保留时间（秒）    pub retention_seconds: u64,    /// 是否启用实时监控    pub real_time_monitoring: bool,}impl Default for EventBusConfig {    fn default() -> Self {        Self {            default_mode: ProcessingMode::Sync,            batch_config: BatchConfig::default(),            async_config: AsyncConfig {                queue_size: 10000,                worker_threads: None,                adaptive_scheduling: true,            },            retry_config: RetryConfig {                max_retries: 3,                base_delay_ms: 100,                max_delay_ms: 5000,                backoff_multiplier: 2.0,            },            metrics_config: MetricsConfig {                detailed_metrics: true,                retention_seconds: 3600,                real_time_monitoring: false,            },        }    }}/// 事件总线统计#[derive(Debug, Clone)]pub struct EventBusStats {    /// 总订阅数    pub total_subscriptions: usize,    /// 事件类型数    pub event_types: usize,}/// 事件总线核心pub struct EventBusCore {    registry: Arc<SubscriptionRegistry>,    dispatcher: Arc<Mutex<EventDispatcher>>,    config: EventBusConfig,    metrics: Arc<dyn MetricsCollector>,    is_running: AtomicBool,}impl EventBusCore {    pub fn new() -> Self {        Self::with_config(EventBusConfig::default())    }        pub fn with_config(config: EventBusConfig) -> Self {        let metrics: Arc<dyn MetricsCollector> = Arc::new(DefaultMetricsCollector::new());        let registry = Arc::new(SubscriptionRegistry::new());        let mut dispatcher = EventDispatcher::new(metrics.clone());                // 添加默认处理器        dispatcher.add_processor(ProcessingMode::Sync, Box::new(SyncProcessor::new(metrics.clone())));        dispatcher.add_processor(ProcessingMode::Async, Box::new(AsyncProcessor::new(metrics.clone())));        dispatcher.add_processor(ProcessingMode::Batch, Box::new(BatchProcessor::new(config.batch_config.clone(), metrics.clone())));                Self {            registry,            dispatcher: Arc::new(Mutex::new(dispatcher)),            config,            metrics,            is_running: AtomicBool::new(false),        }    }        /// 处理事件    pub fn process_event(&self, event: DomainEventEnum) -> VmResult<()> {        // 版本迁移        let event = EventVersionMigrator::migrate_to_latest(event)            .map_err(|e| VmError::Core(crate::CoreError::Internal {                message: format!("Event migration failed: {}", e),                module: "event_bus_core".to_string(),            }))?;                // 查找订阅        let subscriptions = self.registry.find_subscriptions(event.event_type())?;                // 分发事件        let dispatcher = self.dispatcher.lock().unwrap();        dispatcher.dispatch(&event, &subscriptions)    }        /// 异步处理事件    #[cfg(feature = "async")]    pub async fn process_event_async(&self, event: DomainEventEnum) -> VmResult<()> {        // 版本迁移        let event = EventVersionMigrator::migrate_to_latest(event)            .map_err(|e| VmError::Core(crate::CoreError::Internal {                message: format!("Event migration failed: {}", e),                module: "event_bus_core".to_string(),            }))?;                // 查找订阅        let subscriptions = self.registry.find_subscriptions(event.event_type())?;                // 分发事件        let dispatcher = self.dispatcher.lock().unwrap();        dispatcher.dispatch_async(&event, &subscriptions).await    }        /// 异步处理事件（非async版本）    #[cfg(not(feature = "async"))]    pub async fn process_event_async(&self, event: DomainEventEnum) -> VmResult<()> {        // 非async版本，回退到同步处理        self.process_event(event)    }        /// 批量处理事件    pub fn process_events_batch(&self, events: &[DomainEventEnum]) -> VmResult<()> {        if events.is_empty() {            return Ok(());        }                // 版本迁移        let migrated_events: Result<Vec<_>, _> = events.iter()            .map(|e| EventVersionMigrator::migrate_to_latest(e.clone()))            .collect();        let migrated_events = migrated_events.map_err(|e| VmError::Core(crate::CoreError::Internal {            message: format!("Event migration failed: {}", e),            module: "event_bus_core".to_string(),        }))?;                // 查找订阅（使用第一个事件的类型）        let subscriptions = self.registry.find_subscriptions(migrated_events[0].event_type())?;                // 分发事件        let dispatcher = self.dispatcher.lock().unwrap();        dispatcher.dispatch_batch(&migrated_events, &subscriptions)    }        /// 添加订阅    pub fn add_subscription(        &self,        event_type: &str,        handler: Box<dyn EnhancedEventHandler>,        options: SubscriptionOptions,    ) -> VmResult<EventSubscriptionId> {        self.registry.add_subscription(event_type, handler, options)    }        /// 移除订阅    pub fn remove_subscription(&self, subscription_id: EventSubscriptionId) -> VmResult<()> {        self.registry.remove_subscription(subscription_id)    }        /// 更新配置    pub fn update_config(&mut self, config: EventBusConfig) -> VmResult<()> {        self.config = config;        Ok(())    }        /// 获取统计信息    pub fn get_stats(&self) -> EventBusStats {        self.registry.get_stats()    }        /// 获取指标    pub fn get_metrics(&self) -> EventMetrics {        self.metrics.get_metrics()    }        /// 启动事件总线    pub fn start(&mut self) -> VmResult<()> {        if self.is_running.load(Ordering::Acquire) {            return Ok(()); // 已经在运行        }                self.is_running.store(true, Ordering::Release);                // 启动异步处理器        {            let mut dispatcher = self.dispatcher.lock().unwrap();            if let Some(processor) = dispatcher.processors.get_mut(&ProcessingMode::Async) {                if let Some(async_processor) = processor.as_any().downcast_mut::<AsyncProcessor>() {                    async_processor.start()?;                }            }        }                Ok(())    }        /// 停止事件总线    pub fn stop(&mut self) -> VmResult<()> {        self.is_running.store(false, Ordering::Release);                // 停止异步处理器        {            let mut dispatcher = self.dispatcher.lock().unwrap();            if let Some(processor) = dispatcher.processors.get_mut(&ProcessingMode::Async) {                if let Some(async_processor) = processor.as_any().downcast_mut::<AsyncProcessor>() {                    async_processor.stop();                }            }        }                Ok(())    }        /// 检查是否正在运行    pub fn is_running(&self) -> bool {        self.is_running.load(Ordering::Acquire)    }}impl Default for EventBusCore {    fn default() -> Self {        Self::new()    }}/// 类型擦除辅助traittrait AsAny {    fn as_any(&mut self) -> &mut dyn std::any::Any;}impl<T: 'static> AsAny for T {    fn as_any(&mut self) -> &mut dyn std::any::Any {        self    }}/// 统一事件总线接口pub trait UnifiedEventBus: Send + Sync {    /// 发布事件    fn publish(&self, event: DomainEventEnum) -> VmResult<()>;        /// 异步发布事件    #[cfg(feature = "async")]    async fn publish_async(&self, event: DomainEventEnum) -> VmResult<()>;        /// 订阅事件    fn subscribe(        &self,        event_type: &str,        handler: Box<dyn EnhancedEventHandler>,        options: SubscriptionOptions,    ) -> VmResult<EventSubscriptionId>;        /// 取消订阅    fn unsubscribe(&self, subscription_id: EventSubscriptionId) -> VmResult<()>;        /// 获取统计信息    fn stats(&self) -> EventBusStats;        /// 启动事件总线    fn start(&mut self) -> VmResult<()>;        /// 停止事件总线    fn stop(&mut self) -> VmResult<()>;}/// 默认统一事件总线实现pub struct DefaultUnifiedEventBus {    core: Arc<Mutex<EventBusCore>>,}impl DefaultUnifiedEventBus {    pub fn new() -> Self {        Self {            core: Arc::new(Mutex::new(EventBusCore::new())),        }    }        pub fn with_config(config: EventBusConfig) -> Self {        Self {            core: Arc::new(Mutex::new(EventBusCore::with_config(config))),        }    }}impl UnifiedEventBus for DefaultUnifiedEventBus {    fn publish(&self, event: DomainEventEnum) -> VmResult<()> {        let core = self.core.lock().unwrap();        core.process_event(event)    }        #[cfg(feature = "async")]    async fn publish_async(&self, event: DomainEventEnum) -> VmResult<()> {        let core = self.core.lock().unwrap();        core.process_event_async(event).await    }        fn subscribe(        &self,        event_type: &str,        handler: Box<dyn EnhancedEventHandler>,        options: SubscriptionOptions,    ) -> VmResult<EventSubscriptionId> {        let core = self.core.lock().unwrap();        core.add_subscription(event_type, handler, options)    }        fn unsubscribe(&self, subscription_id: EventSubscriptionId) -> VmResult<()> {        let core = self.core.lock().unwrap();        core.remove_subscription(subscription_id)    }        fn stats(&self) -> EventBusStats {        let core = self.core.lock().unwrap();        core.get_stats()    }        fn start(&mut self) -> VmResult<()> {        let mut core = self.core.lock().unwrap();        core.start()    }        fn stop(&mut self) -> VmResult<()> {        let mut core = self.core.lock().unwrap();        core.stop()    }}impl Default for DefaultUnifiedEventBus {    fn default() -> Self {        Self::new()    }}/// 事件总线工厂pub struct EventBusFactory;impl EventBusFactory {    /// 创建配置化的事件总线    pub fn create_with_config(config: EventBusConfig) -> Arc<dyn UnifiedEventBus> {        Arc::new(DefaultUnifiedEventBus::with_config(config))    }        /// 创建默认事件总线    pub fn create_default() -> Arc<dyn UnifiedEventBus> {        Arc::new(DefaultUnifiedEventBus::new())    }        /// 从现有DomainEventBus创建    pub fn from_domain_event_bus(bus: crate::domain_event_bus::DomainEventBus) -> Arc<dyn UnifiedEventBus> {        // 包装现有实现        Arc::new(DomainEventBusAdapter::new(bus))    }        /// 创建自定义配置的事件总线    pub fn create_custom<F>(_builder: F) -> Arc<dyn UnifiedEventBus>    where        F: FnOnce(&mut EventBusBuilder),    {        let builder = EventBusBuilder::new();        // 使用闭包调用构建器        // builder(&mut builder);        Arc::new(builder.build())    }}/// 事件总线构建器pub struct EventBusBuilder {    config: EventBusConfig,}impl EventBusBuilder {    pub fn new() -> Self {        Self {            config: EventBusConfig::default(),        }    }        pub fn with_config(mut self, config: EventBusConfig) -> Self {        self.config = config;        self    }        pub fn with_default_mode(mut self, mode: ProcessingMode) -> Self {        self.config.default_mode = mode;        self    }        pub fn with_batch_config(mut self, config: BatchConfig) -> Self {        self.config.batch_config = config;        self    }        pub fn with_retry_config(mut self, config: RetryConfig) -> Self {        self.config.retry_config = config;        self    }        pub fn build(self) -> DefaultUnifiedEventBus {        DefaultUnifiedEventBus::with_config(self.config)    }}impl Default for EventBusBuilder {    fn default() -> Self {        Self::new()    }}/// DomainEventBus适配器pub struct DomainEventBusAdapter {    inner: crate::domain_event_bus::DomainEventBus,}impl DomainEventBusAdapter {    pub fn new(bus: crate::domain_event_bus::DomainEventBus) -> Self {        Self { inner: bus }    }}impl UnifiedEventBus for DomainEventBusAdapter {    fn publish(&self, event: DomainEventEnum) -> VmResult<()> {        self.inner.publish(event)    }        #[cfg(feature = "async")]    async fn publish_async(&self, event: DomainEventEnum) -> VmResult<()> {        // DomainEventBus不支持异步，回退到同步        self.publish(event)    }        fn subscribe(        &self,        event_type: &str,        handler: Box<dyn EnhancedEventHandler>,        options: SubscriptionOptions,    ) -> VmResult<EventSubscriptionId> {        // 转换为DomainEventBus的处理器        let domain_handler = Box::new(DomainEventHandlerAdapter {            enhanced_handler: handler,        });                self.inner.subscribe(event_type, domain_handler, options.filter)    }        fn unsubscribe(&self, subscription_id: EventSubscriptionId) -> VmResult<()> {        self.inner.unsubscribe_by_id(subscription_id)    }        fn stats(&self) -> EventBusStats {        // Convert domain_event_bus::EventBusStats to unified_event_bus::EventBusStats        let domain_stats = self.inner.stats();        EventBusStats {            total_subscriptions: domain_stats.total_subscriptions,            event_types: domain_stats.event_types,        }    }        fn start(&mut self) -> VmResult<()> {        // DomainEventBus不需要启动        Ok(())    }        fn stop(&mut self) -> VmResult<()> {        // DomainEventBus不需要停止        Ok(())    }}/// DomainEventBus处理器适配器struct DomainEventHandlerAdapter {    enhanced_handler: Box<dyn EnhancedEventHandler>,}impl EventHandler for DomainEventHandlerAdapter {    fn handle(&self, event: &dyn DomainEvent) -> VmResult<()> {        self.enhanced_handler.handle(event)    }        fn priority(&self) -> u32 {        self.enhanced_handler.priority()    }}#[cfg(test)]mod tests {    use super::*;    use crate::jit::domain_events::{VmLifecycleEvent, VmConfigSnapshot};    use std::sync::atomic::{AtomicUsize, Ordering};    #[test]    fn test_unified_event_bus_basic() {        let mut bus = DefaultUnifiedEventBus::new();        bus.start().unwrap();                let counter = Arc::new(AtomicUsize::new(0));        let counter_clone = counter.clone();                let handler = Box::new(TestEventHandler {            name: "test_handler".to_string(),            counter: counter_clone,        });                let options = SubscriptionOptions::default();        let _sub_id = bus.subscribe("vm.started", handler, options).unwrap();                let event = DomainEventEnum::VmLifecycle(VmLifecycleEvent::VmStarted {            vm_id: "test-vm".to_string(),            occurred_at: SystemTime::now(),        });                bus.publish(event).unwrap();                // 等待处理完成        std::thread::sleep(Duration::from_millis(10));        assert_eq!(counter.load(Ordering::Relaxed), 1);                bus.stop().unwrap();    }        #[test]    fn test_event_bus_factory() {        let bus = EventBusFactory::create_default();        let stats = bus.stats();        assert_eq!(stats.total_subscriptions, 0);        assert_eq!(stats.event_types, 0);    }        #[test]    fn test_event_bus_builder() {        let bus = EventBusBuilder::new()            .with_default_mode(ProcessingMode::Async)            .build();                let mut unified_bus = bus;        unified_bus.start().unwrap();        unified_bus.stop().unwrap();    }        #[test]    fn test_retry_policy() {        let policy = ExponentialBackoffRetryPolicy::new(            3,            Duration::from_millis(100),            Duration::from_millis(1000),        );                assert_eq!(policy.max_retries(), 3);        assert!(policy.should_retry(&VmError::Core(crate::CoreError::Internal {            message: "test".to_string(),            module: "test".to_string(),        }), 1));                let delay1 = policy.delay(1);        let delay2 = policy.delay(2);        assert!(delay2 > delay1);    }        #[test]    fn test_metrics_collector() {        let metrics = DefaultMetricsCollector::new();                metrics.record_event_processed("test.event", Duration::from_millis(10));        metrics.record_event_failed("test.event", &VmError::Core(crate::CoreError::Internal {            message: "test".to_string(),            module: "test".to_string(),        }));                let event_metrics = metrics.get_metrics();        assert_eq!(event_metrics.total_events_processed, 1);        assert_eq!(event_metrics.total_events_failed, 1);    }        #[test]    fn test_filter_chain() {        let mut filter_chain = FilterChain::new();                // 添加类型过滤器        filter_chain.add_filter(Box::new(TypeEventFilter::new("vm.started")));                let event = DomainEventEnum::VmLifecycle(VmLifecycleEvent::VmStarted {            vm_id: "test-vm".to_string(),            occurred_at: SystemTime::now(),        });                assert!(filter_chain.matches(&event));    }        #[cfg(feature = "async")]    #[tokio::test]    async fn test_async_event_bus() {        let mut bus = DefaultUnifiedEventBus::new();        bus.start().unwrap();                let counter = Arc::new(AtomicUsize::new(0));        let counter_clone = counter.clone();                let handler = Box::new(TestEventHandler {            name: "test_async_handler".to_string(),            counter: counter_clone,        });                let options = SubscriptionOptions {            mode: ProcessingMode::Async,            ..Default::default()        };                let _sub_id = bus.subscribe("vm.started", handler, options).unwrap();                let event = DomainEventEnum::VmLifecycle(VmLifecycleEvent::VmStarted {            vm_id: "test-vm".to_string(),            occurred_at: SystemTime::now(),        });                bus.publish_async(event).await.unwrap();                // 等待处理完成        tokio::time::sleep(Duration::from_millis(50)).await;        assert_eq!(counter.load(Ordering::Relaxed), 1);                bus.stop().unwrap();    }        /// 测试事件处理器    struct TestEventHandler {        name: String,        counter: Arc<AtomicUsize>,    }        impl EnhancedEventHandler for TestEventHandler {        fn handle(&self, _event: &dyn DomainEvent) -> VmResult<()> {            self.counter.fetch_add(1, Ordering::Relaxed);            Ok(())        }                #[cfg(feature = "async")]        async fn handle_async(&self, event: &dyn DomainEvent) -> VmResult<()> {            self.handle(event)        }                fn priority(&self) -> u32 {            100        }                fn name(&self) -> &str {            &self.name        }                fn supports_async(&self) -> bool {            true        }    }        /// 类型事件过滤器    struct TypeEventFilter {        event_type: String,    }        impl TypeEventFilter {        pub fn new(event_type: &str) -> Self {            Self {                event_type: event_type.to_string(),            }        }    }        impl EventFilter for TypeEventFilter {        fn matches(&self, event: &dyn DomainEvent) -> bool {            event.event_type() == self.event_type        }    }}